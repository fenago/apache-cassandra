{
  "paragraphs": [
    {
      "text": "%sh\nSTATUS=\"$(service cassandra status)\"\n\nif [[ $STATUS == *\"is running\"* ]]; then\n    echo \"Cassandra is running\"\nelse \n    echo \" Cassandra not running .... Starting\"  \n    service cassandra restart > /dev/null 2>&1 &\n    echo \" Started\"  \nfi",
      "user": "anonymous",
      "dateUpdated": "2020-06-09T16:10:16+0000",
      "config": {
        "editorSetting": {
          "language": "sh",
          "editOnDblClick": false,
          "completionSupport": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/sh",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591719016916_-710474991",
      "id": "paragraph_1591519551747_1992496980",
      "dateCreated": "2020-06-09T16:10:16+0000",
      "status": "READY",
      "focus": true,
      "$$hashKey": "object:30408"
    },
    {
      "text": "%md\n\n\nLab 2. Cassandra Data Modeling\n-------------------------------------------\n\n\nIn this lab, we will open the door to the world of Cassandra data\nmodeling. We will briefly go through its building blocks, the main\ndifferences to the relational data model, and examples of constructing\nqueries on a Cassandra data model.\n\nCassandra describes its data model components by using the terms that\nare inherited from the Google BigTable parent, for example, column\nfamily, column, row, and so on. Some of these terms also exist in a\nrelational data model. They, however, have completely different\nmeanings. It often confuses developers and administrators who have a\nbackground in the relational world. At first sight, the Cassandra data\nmodel is counterintuitive and very difficult to grasp and understand.\n\nIn the relational world, you model the data by creating entities and\nassociating them with relationships according to the guidelines governed\nby the relational theories. It means that you can solely concentrate on\nthe logical view or structure of the data without any considerations of\nhow the application accesses and manipulates the data. The objective is\nto have a stable data model complying with the relational guidelines.\nThe design of the application can be done separately. For instance, you\ncan answer different queries by constructing different SQL statements,\nwhich is not of your concern during data modeling. In short, relational\ndata modeling is process oriented, based on a clear separation of\nconcerns.\n\nOn the contrary, in Cassandra, you reverse the above steps and always\nstart from what you want to answer in the queries of the application.\nThe queries exert a considerable amount of influence on the underlying\ndata model. You also need to take the physical storage and the cluster\ntopology into account. Therefore, the query and the data model are\ntwins, as they were born together. Cassandra data modeling is result\noriented based on a clear understanding of how a query works internally\nin Cassandra.\n\nOwing to the unique architecture of Cassandra, many simple things in a\nrelational database, such as sequence and sorting, cannot be presumed.\nThey require your special handling in implementing the same.\nFurthermore, they are usually design decisions that you need to make\nupfront in the process of data modeling. Perhaps it is the cost of the\ntrade-off for the attainment of superb scalability, performance, and\nfault tolerance.\n\nTo enjoy reading this course, you are advised to temporarily think in both\nrelational and NoSQL ways. Although you may not become a friend of\nCassandra, you will have an eye-opening experience in realizing the fact\nthat there exists a different way of working in the world.\n\n\n\nWhat is unique to the Cassandra data model?\n-------------------------------------------------------------\n\n\n\nIf you want me to use just one sentence to describe\nCassandra's data model, I will say it is a non-relational data model,\nperiod. It implies that you need to forget the way you do data modeling\nin a relational database.\n\nYou focus on modeling the data according to relational theories.\nHowever, in Cassandra and even in other NoSQL databases, you need to\nfocus on the application in addition to the data itself. This means you\nneed to think about how you will query the data in the application. It\nis a paradigm shift for those of you coming from the relational world.\nExamples are given in the subsequent sections to make sure that you\nunderstand why you cannot apply relational theories to model data in\nCassandra.\n\nAnother important consideration in Cassandra data\nmodeling is that you need to take the physical topology of a Cassandra\ncluster into account. In a relational database, the primary goal is to\nremove data duplication through normalization to have a single source of\ndata. It makes a relational database ACID compliant very easily. The\nrelated storage space required is also optimized. Conversely, Cassandra\nis designed to work in a massive-scale, distributed environment in which\nACID compliance is difficult to achieve, and replication is a must. You\nmust be aware of such differences in the process of data modeling in\nCassandra.\n\n\n\n### Map and SortedMap\n\n\nIn\n*Bird's Eye View of Cassandra*, you learned that\nCassandra's storage model is based on BigTable, a column-oriented\nstore. A column-oriented store is a multidimensional map. Specifically,\nit is a data structure known as \n**Map**. An example of the declaration\nof map data structure is as follows:\n\n\n``` {.programlisting .language-markup}\nMap<RowKey, SortedMap<ColumnKey, ColumnValue>>\n```\n\nThe `Map` data structure gives efficient\nkey lookup, and the sorted nature provides efficient scans.\n`RowKey` is a unique key and can hold a value. The inner\n`SortedMap` data structure allows a\nvariable number of `ColumnKey` values. This is the trick that\nCassandra uses to be schemaless and to allow the data model to evolve\norganically over time. It should be noted that each column has a\nclient-supplied timestamp associated, but it can be ignored during data\nmodeling. Cassandra uses the timestamp internally to resolve transaction\nconflicts.\n\nIn a relational database, column names can be only\nstrings and be stored in the table metadata. In Cassandra, both\n`RowKey` and `ColumnKey` can be strings,\nlong integers, Universal Unique IDs, or any kind of\nbyte arrays. In addition, `ColumnKey` is stored in each\ncolumn. You may opine that it wastes storage space to repeatedly store\nthe `ColumnKey` values. However, it brings us a very powerful\nfeature of Cassandra. `RowKey` and `ColumnKey`\ncan store data themselves and not just in\n`ColumnValue`. We will not go too deep\ninto this at the moment; we will revisit it in later labs.\n\n\n### Note\n\n**Universal Unique ID**\n\n**Universal Unique ID** (**UUID**)\n is an **Internet Engineering Task Force**\n(**IETF**) standard, **Request for\nComments** (**RFC**) 4122, with the intent of\nenabling distributed systems to uniquely identify\ninformation without significant central coordination. It is a 128-bit\nnumber represented by 32 lowercase hexadecimal digits, displayed in five\ngroups separated by hyphens, for example:\n`0a317b38-53bf-4cad-a2c9-4c5b8e7806a2`\n:::\n\n\n### Logical data structure\n\n\nThere are a few logical building blocks to come up\nwith a Cassandra data model. Each of them is\nintroduced as follows.\n\n\n\n#### Column\n\n\nColumn is the  smallest data model element and\nstorage unit in Cassandra. Though it also exists in\na relational database, it is a different thing in Cassandra. As shown in\nthe following figure, a column is a name-value pair with a timestamp and\nan optional **Time-To-Live** (**TTL**)\n value:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_02_01.jpg)\n\n:::\nThe elements of a column\n:::\n\nThe name and the value (`ColumnKey` and\n`ColumnValue` in `SortedMap` respectively) are byte\narrays, and Cassandra provides a bunch of built-in\ndata types that influence the sort order of the values. The timestamp\nhere is for conflict resolution and is supplied by the client\napplication during a write operation. Time-To-Live is an optional\nexpiration value used to mark the column deleted after expiration. The\ncolumn is then physically removed during compaction.\n\n\n#### Row\n\n\nOne level up is a row, as \ndepicted in the following figure. It is a set of orderable\ncolumns with a unique row key, also known as a primary key:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_02_02.jpg)\n\n:::\nThe structure of a row\n:::\n\nThe row key can be any one of the same built-in\ndata types as those for columns. What orderable\nmeans is that columns are stored in sorted order by their column names.\n\n\n### Note\n\nSort order is extremely important because Cassandra\ncannot sort by value as we do in a relational database.\n\nDifferent names in columns are possible in different rows. That is why\nCassandra is both row oriented and column oriented. It should be\nremarked that there is no timestamp for rows. Moreover, a row cannot be\nsplit to store across two nodes in the cluster. It means that if a row\nexists on a node, the entire row exists on that node.\n\n\n#### Column family\n\n\nThe next level column\nfamily. As shown in the  following figure, it is a\ncontainer for a set of rows with a name:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_02_03.jpg)\n\n:::\nThe structure of a column family\n:::\n\nThe row keys in a column family must be unique and are used to order\nrows. A column family is analogous to a table in a relational database,\nbut you should not go too far with this idea. A column family provides\ngreater flexibility by allowing different columns in different rows. Any\ncolumn can be freely added to any column family at any time. Once again,\nit helps Cassandra be schemaless.\n\nColumns in a column family are sorted by a\ncomparator. The comparator determines how columns\nare sorted and ordered when Cassandra returns the columns in a query. It\naccepts long, byte and UTF8 for the data type of the column name, and\nthe sort order in which columns are stored within a row.\n\nPhysically, column families are stored in individual files on a disk.\nTherefore, it is important to keep related columns in the same column\nfamily to save disk I/O and improve performance.\n\n\n#### Keyspace\n\n\nThe outermost data model element is \n keyspace, as illustrated in the following figure:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_02_04.jpg)\n\n:::\nThe structure of a keyspace\n:::\n\nKeyspace is a set of column families and super column families, which\nwill be introduced in the following section. It is analogous to a schema\nor database in the relational world. Each Cassandra instance has a\nsystem keyspace to keep system-wide metadata.\n\nKeyspace contains replication settings controlling how data is\ndistributed and replicated in the cluster. Very often, one cluster\ncontains just one keyspace.\n\n\n#### Super column and super column family\n\n\nAs shown in the  following figure, a super\ncolumn is a named map of columns and a super column\nfamily collection of\nsuper columns:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_02_05.jpg)\n\n:::\nThe structure of a super column and a super column family\n:::\n\nSuper columns were popular in the earlier versions of Cassandra but are\nnot recommended anymore since they are not supported by the Cassandra\nQuery Language (CQL), a SQL-like language to manipulate and query\nCassandra, and must be accessed by using the low-level Thrift API. A\ncolumn family is enough in most cases.\n\n\n### Note\n\n**Thrift**\n\nThrift is a software framework for the development\nof scalable cross-language services. It combines a software stack with a\ncode generation engine to build services that work efficiently and\nseamlessly with numerous programming languages. It is used as a\n**remote procedure call** (**RPC**)\n framework and was developed at Facebook Inc. It is now an\nopen source project in the Apache Software Foundation.\n\nThere are other alternatives, for example, Protocol Buffers, Avro,\nMessagePack, JSON, and so on.\n\n\n### Collections\n\n\nCassandracollections,\nnamely sets, lists, and maps, as parts of the data model. Collections\nare a complex type that can provide flexibility in querying.\n\nCassandra allows the following collections:\n\n\n-   **Sets**: These provide a \n    way of keeping a unique set of values. It means that one\n    can easily solve the problem of tracking unique values.\n\n-   **Lists**: These are \n    suitable for maintaining the order\n    of the values in the collection. Lists are ordered by the natural\n    order of the type selected.\n\n-   **Maps**: These are similar to\n    a store of key-value pairs. They are useful for\n    storing table-like data within a single row. They can be a\n    workaround of not having joins.\n\nHere we only provided a brief introduction, and we will revisit the\ncollections in subsequent labs.\n\n\n### No foreign key\n\n\nForeign keys are used in a relational database to\nmaintain referential integrity that defines the relationship between two\ntables. They are used to enforce relationships in a relational data\nmodel such that the data in different but related tables can be joined\nto answer a query. Cassandra does not have the concept of referential\nintegrity and hence, joins are not allowed either.\n\n\n### No join\n\n\nForeign keys and joins are the product of\nnormalization in a relational data model. Cassandra has neither foreign\nkeys nor joins. Instead, it encourages and performs best when the data\nmodel is denormalized.\n\nIndeed, denormalization is not completely\ndisallowed in the relational world, for example, a data warehouse built\non a relational database. In practice, denormalization is a solution to\nthe problem of poor performance of highly complex relational queries\ninvolving a large number of table joins.\n\n\n### Note\n\nIn Cassandra, denormalization is normal.\n\nForeign keys and joins can be avoided in Cassandra with proper data\nmodeling.\n\n\n### No sequence\n\n\nIn a relational database, sequences are usually\nused to generate unique values for a surrogate key. Cassandra has no\nsequences because it is extremely difficult to implement in a\npeer-to-peer distributed system. There are however workarounds, which\nare as follows:\n\n\n-   Using part of the data to generate a unique key\n\n-   Using a UUID\n:::\n\nIn most cases, the best practice is to select the second workaround.\n\n\n### Counter\n\n\nA counter columna special\ncolumn used to store a number that keeps counting values. Counting can\nbe either increment or decrement and timestamp is not required.\n\nThe counter column should not be used to generate surrogate keys. It is\njust designed to hold a distributed counter appropriate for distributed\ncounting. Also bear in mind that updating a counter is not idempotent.\n\n\n### Note\n\n**Idempotent**\n\nIdempotent was originally a term in mathematics.\nBut in computer science, idempotent is used more comprehensively to\ndescribe an operation that will produce the same results if executed\nonce or multiple times.\n\n\n### Time-To-Live\n\n\n**Time-To-Live** (**TTL**) is\nset on columns only. The unit is in seconds. When set\n on a column, it automatically counts down and will then be\nexpired on the server side without any intervention of the client\napplication.\n\nTypical use cases are for the generation of security token and one-time\ntoken, automatic purging of outdated columns, and so on.\n\n\n### Secondary index\n\n\nOne important thing you need to remember is that\nthe secondary index in Cassandra is not identical to that in a\nrelational database. The secondary index in Cassandra can be created to\nquery a column that is not a part of the primary key. A column family\ncan have more than one secondary index. Behind the scenes, it is\nimplemented as a separate hidden table which is maintained automatically\nby Cassandra's internal process.\n\nThe secondary index does not support collections\nand cannot be created on the primary key itself. The major difference\nbetween a primary key and a secondary index is that the former is a\ndistributed index while the latter is a local index. The primary key is\nused to determine the node location and so, for a given row key, its\nnode location can be found immediately. However, the secondary index is\nused just to index data on the local node, and it might not be possible\nto know immediately the locations of all matched rows without having\nexamined all the nodes in the cluster. Hence, the performance is\nunpredictable.\n\nMore information on secondary keys will be provided as we go through the\nlater labs.\n\n\n\nModeling by query\n-------------------\n\n\nIn the previous section, we gained a basic\nunderstanding of the differences between a relational database and\nCassandra. The most important difference is that a relational database\nmodels data by relationships whereas Cassandra models data by query. Now\nlet us start with a simple example to look into what modeling by query\nmeans.\n\n\n\n### Relational version\n\n\nThe following figure shows a simple relational data\nmodel of a stock quote application:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_02_06.jpg)\n\n:::\nThe relational data model of a stock quote application (Source: Yahoo!\nFinance)\n:::\n\nThe `stock_symbol` table is an entity representing the stock\nmaster information such as the symbol of a stock, the description of the\nstock, and the exchange that the stock is traded. The\n`stock_ticker` table is another entity storing the prices of\n`open` , `high` , `low` , `close` ,\nand the transacted `volume` of a stock on a trading day.\nObviously the two tables have a relationship based on the\n`symbol` column. It is a well-known one-to-many relationship.\n\nThe following is the **Data Definition Language**\n(**DDL**) of the two tables:\n\n\n``` {.programlisting .language-markup}\nCREATE TABLE stock_symbol (\nsymbol varchar PRIMARY KEY,\ndescription varchar,\nexchange varchar\n);\n\nCREATE TABLE stock_ticker (\nsymbol varchar references stock_symbol(symbol),\ntick_date varchar,\nopen decimal,\nhigh decimal,\nlow decimal,\nclose decimal,\nvolume bigint,\nPRIMARY KEY (symbol, tick_date)\n);\n```\n",
      "user": "anonymous",
      "dateUpdated": "2020-06-09T16:10:16+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h2>Lab 2. Cassandra Data Modeling</h2>\n<p>In this lab, we will open the door to the world of Cassandra data<br />\nmodeling. We will briefly go through its building blocks, the main<br />\ndifferences to the relational data model, and examples of constructing<br />\nqueries on a Cassandra data model.</p>\n<p>Cassandra describes its data model components by using the terms that<br />\nare inherited from the Google BigTable parent, for example, column<br />\nfamily, column, row, and so on. Some of these terms also exist in a<br />\nrelational data model. They, however, have completely different<br />\nmeanings. It often confuses developers and administrators who have a<br />\nbackground in the relational world. At first sight, the Cassandra data<br />\nmodel is counterintuitive and very difficult to grasp and understand.</p>\n<p>In the relational world, you model the data by creating entities and<br />\nassociating them with relationships according to the guidelines governed<br />\nby the relational theories. It means that you can solely concentrate on<br />\nthe logical view or structure of the data without any considerations of<br />\nhow the application accesses and manipulates the data. The objective is<br />\nto have a stable data model complying with the relational guidelines.<br />\nThe design of the application can be done separately. For instance, you<br />\ncan answer different queries by constructing different SQL statements,<br />\nwhich is not of your concern during data modeling. In short, relational<br />\ndata modeling is process oriented, based on a clear separation of<br />\nconcerns.</p>\n<p>On the contrary, in Cassandra, you reverse the above steps and always<br />\nstart from what you want to answer in the queries of the application.<br />\nThe queries exert a considerable amount of influence on the underlying<br />\ndata model. You also need to take the physical storage and the cluster<br />\ntopology into account. Therefore, the query and the data model are<br />\ntwins, as they were born together. Cassandra data modeling is result<br />\noriented based on a clear understanding of how a query works internally<br />\nin Cassandra.</p>\n<p>Owing to the unique architecture of Cassandra, many simple things in a<br />\nrelational database, such as sequence and sorting, cannot be presumed.<br />\nThey require your special handling in implementing the same.<br />\nFurthermore, they are usually design decisions that you need to make<br />\nupfront in the process of data modeling. Perhaps it is the cost of the<br />\ntrade-off for the attainment of superb scalability, performance, and<br />\nfault tolerance.</p>\n<p>To enjoy reading this course, you are advised to temporarily think in both<br />\nrelational and NoSQL ways. Although you may not become a friend of<br />\nCassandra, you will have an eye-opening experience in realizing the fact<br />\nthat there exists a different way of working in the world.</p>\n<h2>What is unique to the Cassandra data model?</h2>\n<p>If you want me to use just one sentence to describe<br />\nCassandra&rsquo;s data model, I will say it is a non-relational data model,<br />\nperiod. It implies that you need to forget the way you do data modeling<br />\nin a relational database.</p>\n<p>You focus on modeling the data according to relational theories.<br />\nHowever, in Cassandra and even in other NoSQL databases, you need to<br />\nfocus on the application in addition to the data itself. This means you<br />\nneed to think about how you will query the data in the application. It<br />\nis a paradigm shift for those of you coming from the relational world.<br />\nExamples are given in the subsequent sections to make sure that you<br />\nunderstand why you cannot apply relational theories to model data in<br />\nCassandra.</p>\n<p>Another important consideration in Cassandra data<br />\nmodeling is that you need to take the physical topology of a Cassandra<br />\ncluster into account. In a relational database, the primary goal is to<br />\nremove data duplication through normalization to have a single source of<br />\ndata. It makes a relational database ACID compliant very easily. The<br />\nrelated storage space required is also optimized. Conversely, Cassandra<br />\nis designed to work in a massive-scale, distributed environment in which<br />\nACID compliance is difficult to achieve, and replication is a must. You<br />\nmust be aware of such differences in the process of data modeling in<br />\nCassandra.</p>\n<h3>Map and SortedMap</h3>\n<p>In<br />\n<em>Bird&rsquo;s Eye View of Cassandra</em>, you learned that<br />\nCassandra&rsquo;s storage model is based on BigTable, a column-oriented<br />\nstore. A column-oriented store is a multidimensional map. Specifically,<br />\nit is a data structure known as<br />\n<strong>Map</strong>. An example of the declaration<br />\nof map data structure is as follows:</p>\n<pre><code class=\"language-{.programlisting\">Map&lt;RowKey, SortedMap&lt;ColumnKey, ColumnValue&gt;&gt;\n</code></pre>\n<p>The <code>Map</code> data structure gives efficient<br />\nkey lookup, and the sorted nature provides efficient scans.<br />\n<code>RowKey</code> is a unique key and can hold a value. The inner<br />\n<code>SortedMap</code> data structure allows a<br />\nvariable number of <code>ColumnKey</code> values. This is the trick that<br />\nCassandra uses to be schemaless and to allow the data model to evolve<br />\norganically over time. It should be noted that each column has a<br />\nclient-supplied timestamp associated, but it can be ignored during data<br />\nmodeling. Cassandra uses the timestamp internally to resolve transaction<br />\nconflicts.</p>\n<p>In a relational database, column names can be only<br />\nstrings and be stored in the table metadata. In Cassandra, both<br />\n<code>RowKey</code> and <code>ColumnKey</code> can be strings,<br />\nlong integers, Universal Unique IDs, or any kind of<br />\nbyte arrays. In addition, <code>ColumnKey</code> is stored in each<br />\ncolumn. You may opine that it wastes storage space to repeatedly store<br />\nthe <code>ColumnKey</code> values. However, it brings us a very powerful<br />\nfeature of Cassandra. <code>RowKey</code> and <code>ColumnKey</code><br />\ncan store data themselves and not just in<br />\n<code>ColumnValue</code>. We will not go too deep<br />\ninto this at the moment; we will revisit it in later labs.</p>\n<h3>Note</h3>\n<p><strong>Universal Unique ID</strong></p>\n<p><strong>Universal Unique ID</strong> (<strong>UUID</strong>)<br />\nis an <strong>Internet Engineering Task Force</strong><br />\n(<strong>IETF</strong>) standard, <strong>Request for<br />\nComments</strong> (<strong>RFC</strong>) 4122, with the intent of<br />\nenabling distributed systems to uniquely identify<br />\ninformation without significant central coordination. It is a 128-bit<br />\nnumber represented by 32 lowercase hexadecimal digits, displayed in five<br />\ngroups separated by hyphens, for example:<br />\n<code>0a317b38-53bf-4cad-a2c9-4c5b8e7806a2</code><br />\n:::</p>\n<h3>Logical data structure</h3>\n<p>There are a few logical building blocks to come up<br />\nwith a Cassandra data model. Each of them is<br />\nintroduced as follows.</p>\n<h4>Column</h4>\n<p>Column is the  smallest data model element and<br />\nstorage unit in Cassandra. Though it also exists in<br />\na relational database, it is a different thing in Cassandra. As shown in<br />\nthe following figure, a column is a name-value pair with a timestamp and<br />\nan optional <strong>Time-To-Live</strong> (<strong>TTL</strong>)<br />\nvalue:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_02_01.jpg\" alt=\"\" /></p>\n<p>:::<br />\nThe elements of a column<br />\n:::</p>\n<p>The name and the value (<code>ColumnKey</code> and<br />\n<code>ColumnValue</code> in <code>SortedMap</code> respectively) are byte<br />\narrays, and Cassandra provides a bunch of built-in<br />\ndata types that influence the sort order of the values. The timestamp<br />\nhere is for conflict resolution and is supplied by the client<br />\napplication during a write operation. Time-To-Live is an optional<br />\nexpiration value used to mark the column deleted after expiration. The<br />\ncolumn is then physically removed during compaction.</p>\n<h4>Row</h4>\n<p>One level up is a row, as<br />\ndepicted in the following figure. It is a set of orderable<br />\ncolumns with a unique row key, also known as a primary key:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_02_02.jpg\" alt=\"\" /></p>\n<p>:::<br />\nThe structure of a row<br />\n:::</p>\n<p>The row key can be any one of the same built-in<br />\ndata types as those for columns. What orderable<br />\nmeans is that columns are stored in sorted order by their column names.</p>\n<h3>Note</h3>\n<p>Sort order is extremely important because Cassandra<br />\ncannot sort by value as we do in a relational database.</p>\n<p>Different names in columns are possible in different rows. That is why<br />\nCassandra is both row oriented and column oriented. It should be<br />\nremarked that there is no timestamp for rows. Moreover, a row cannot be<br />\nsplit to store across two nodes in the cluster. It means that if a row<br />\nexists on a node, the entire row exists on that node.</p>\n<h4>Column family</h4>\n<p>The next level column<br />\nfamily. As shown in the  following figure, it is a<br />\ncontainer for a set of rows with a name:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_02_03.jpg\" alt=\"\" /></p>\n<p>:::<br />\nThe structure of a column family<br />\n:::</p>\n<p>The row keys in a column family must be unique and are used to order<br />\nrows. A column family is analogous to a table in a relational database,<br />\nbut you should not go too far with this idea. A column family provides<br />\ngreater flexibility by allowing different columns in different rows. Any<br />\ncolumn can be freely added to any column family at any time. Once again,<br />\nit helps Cassandra be schemaless.</p>\n<p>Columns in a column family are sorted by a<br />\ncomparator. The comparator determines how columns<br />\nare sorted and ordered when Cassandra returns the columns in a query. It<br />\naccepts long, byte and UTF8 for the data type of the column name, and<br />\nthe sort order in which columns are stored within a row.</p>\n<p>Physically, column families are stored in individual files on a disk.<br />\nTherefore, it is important to keep related columns in the same column<br />\nfamily to save disk I/O and improve performance.</p>\n<h4>Keyspace</h4>\n<p>The outermost data model element is<br />\nkeyspace, as illustrated in the following figure:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_02_04.jpg\" alt=\"\" /></p>\n<p>:::<br />\nThe structure of a keyspace<br />\n:::</p>\n<p>Keyspace is a set of column families and super column families, which<br />\nwill be introduced in the following section. It is analogous to a schema<br />\nor database in the relational world. Each Cassandra instance has a<br />\nsystem keyspace to keep system-wide metadata.</p>\n<p>Keyspace contains replication settings controlling how data is<br />\ndistributed and replicated in the cluster. Very often, one cluster<br />\ncontains just one keyspace.</p>\n<h4>Super column and super column family</h4>\n<p>As shown in the  following figure, a super<br />\ncolumn is a named map of columns and a super column<br />\nfamily collection of<br />\nsuper columns:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_02_05.jpg\" alt=\"\" /></p>\n<p>:::<br />\nThe structure of a super column and a super column family<br />\n:::</p>\n<p>Super columns were popular in the earlier versions of Cassandra but are<br />\nnot recommended anymore since they are not supported by the Cassandra<br />\nQuery Language (CQL), a SQL-like language to manipulate and query<br />\nCassandra, and must be accessed by using the low-level Thrift API. A<br />\ncolumn family is enough in most cases.</p>\n<h3>Note</h3>\n<p><strong>Thrift</strong></p>\n<p>Thrift is a software framework for the development<br />\nof scalable cross-language services. It combines a software stack with a<br />\ncode generation engine to build services that work efficiently and<br />\nseamlessly with numerous programming languages. It is used as a<br />\n<strong>remote procedure call</strong> (<strong>RPC</strong>)<br />\nframework and was developed at Facebook Inc. It is now an<br />\nopen source project in the Apache Software Foundation.</p>\n<p>There are other alternatives, for example, Protocol Buffers, Avro,<br />\nMessagePack, JSON, and so on.</p>\n<h3>Collections</h3>\n<p>Cassandracollections,<br />\nnamely sets, lists, and maps, as parts of the data model. Collections<br />\nare a complex type that can provide flexibility in querying.</p>\n<p>Cassandra allows the following collections:</p>\n<ul>\n<li>\n<p><strong>Sets</strong>: These provide a<br />\nway of keeping a unique set of values. It means that one<br />\ncan easily solve the problem of tracking unique values.</p>\n</li>\n<li>\n<p><strong>Lists</strong>: These are<br />\nsuitable for maintaining the order<br />\nof the values in the collection. Lists are ordered by the natural<br />\norder of the type selected.</p>\n</li>\n<li>\n<p><strong>Maps</strong>: These are similar to<br />\na store of key-value pairs. They are useful for<br />\nstoring table-like data within a single row. They can be a<br />\nworkaround of not having joins.</p>\n</li>\n</ul>\n<p>Here we only provided a brief introduction, and we will revisit the<br />\ncollections in subsequent labs.</p>\n<h3>No foreign key</h3>\n<p>Foreign keys are used in a relational database to<br />\nmaintain referential integrity that defines the relationship between two<br />\ntables. They are used to enforce relationships in a relational data<br />\nmodel such that the data in different but related tables can be joined<br />\nto answer a query. Cassandra does not have the concept of referential<br />\nintegrity and hence, joins are not allowed either.</p>\n<h3>No join</h3>\n<p>Foreign keys and joins are the product of<br />\nnormalization in a relational data model. Cassandra has neither foreign<br />\nkeys nor joins. Instead, it encourages and performs best when the data<br />\nmodel is denormalized.</p>\n<p>Indeed, denormalization is not completely<br />\ndisallowed in the relational world, for example, a data warehouse built<br />\non a relational database. In practice, denormalization is a solution to<br />\nthe problem of poor performance of highly complex relational queries<br />\ninvolving a large number of table joins.</p>\n<h3>Note</h3>\n<p>In Cassandra, denormalization is normal.</p>\n<p>Foreign keys and joins can be avoided in Cassandra with proper data<br />\nmodeling.</p>\n<h3>No sequence</h3>\n<p>In a relational database, sequences are usually<br />\nused to generate unique values for a surrogate key. Cassandra has no<br />\nsequences because it is extremely difficult to implement in a<br />\npeer-to-peer distributed system. There are however workarounds, which<br />\nare as follows:</p>\n<ul>\n<li>\n<p>Using part of the data to generate a unique key</p>\n</li>\n<li>\n<p>Using a UUID<br />\n:::</p>\n</li>\n</ul>\n<p>In most cases, the best practice is to select the second workaround.</p>\n<h3>Counter</h3>\n<p>A counter columna special<br />\ncolumn used to store a number that keeps counting values. Counting can<br />\nbe either increment or decrement and timestamp is not required.</p>\n<p>The counter column should not be used to generate surrogate keys. It is<br />\njust designed to hold a distributed counter appropriate for distributed<br />\ncounting. Also bear in mind that updating a counter is not idempotent.</p>\n<h3>Note</h3>\n<p><strong>Idempotent</strong></p>\n<p>Idempotent was originally a term in mathematics.<br />\nBut in computer science, idempotent is used more comprehensively to<br />\ndescribe an operation that will produce the same results if executed<br />\nonce or multiple times.</p>\n<h3>Time-To-Live</h3>\n<p><strong>Time-To-Live</strong> (<strong>TTL</strong>) is<br />\nset on columns only. The unit is in seconds. When set<br />\non a column, it automatically counts down and will then be<br />\nexpired on the server side without any intervention of the client<br />\napplication.</p>\n<p>Typical use cases are for the generation of security token and one-time<br />\ntoken, automatic purging of outdated columns, and so on.</p>\n<h3>Secondary index</h3>\n<p>One important thing you need to remember is that<br />\nthe secondary index in Cassandra is not identical to that in a<br />\nrelational database. The secondary index in Cassandra can be created to<br />\nquery a column that is not a part of the primary key. A column family<br />\ncan have more than one secondary index. Behind the scenes, it is<br />\nimplemented as a separate hidden table which is maintained automatically<br />\nby Cassandra&rsquo;s internal process.</p>\n<p>The secondary index does not support collections<br />\nand cannot be created on the primary key itself. The major difference<br />\nbetween a primary key and a secondary index is that the former is a<br />\ndistributed index while the latter is a local index. The primary key is<br />\nused to determine the node location and so, for a given row key, its<br />\nnode location can be found immediately. However, the secondary index is<br />\nused just to index data on the local node, and it might not be possible<br />\nto know immediately the locations of all matched rows without having<br />\nexamined all the nodes in the cluster. Hence, the performance is<br />\nunpredictable.</p>\n<p>More information on secondary keys will be provided as we go through the<br />\nlater labs.</p>\n<h2>Modeling by query</h2>\n<p>In the previous section, we gained a basic<br />\nunderstanding of the differences between a relational database and<br />\nCassandra. The most important difference is that a relational database<br />\nmodels data by relationships whereas Cassandra models data by query. Now<br />\nlet us start with a simple example to look into what modeling by query<br />\nmeans.</p>\n<h3>Relational version</h3>\n<p>The following figure shows a simple relational data<br />\nmodel of a stock quote application:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_02_06.jpg\" alt=\"\" /></p>\n<p>:::<br />\nThe relational data model of a stock quote application (Source: Yahoo!<br />\nFinance)<br />\n:::</p>\n<p>The <code>stock_symbol</code> table is an entity representing the stock<br />\nmaster information such as the symbol of a stock, the description of the<br />\nstock, and the exchange that the stock is traded. The<br />\n<code>stock_ticker</code> table is another entity storing the prices of<br />\n<code>open</code> , <code>high</code> , <code>low</code> , <code>close</code> ,<br />\nand the transacted <code>volume</code> of a stock on a trading day.<br />\nObviously the two tables have a relationship based on the<br />\n<code>symbol</code> column. It is a well-known one-to-many relationship.</p>\n<p>The following is the <strong>Data Definition Language</strong><br />\n(<strong>DDL</strong>) of the two tables:</p>\n<pre><code class=\"language-{.programlisting\">CREATE TABLE stock_symbol (\nsymbol varchar PRIMARY KEY,\ndescription varchar,\nexchange varchar\n);\n\nCREATE TABLE stock_ticker (\nsymbol varchar references stock_symbol(symbol),\ntick_date varchar,\nopen decimal,\nhigh decimal,\nlow decimal,\nclose decimal,\nvolume bigint,\nPRIMARY KEY (symbol, tick_date)\n);\n</code></pre>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591719016917_255726695",
      "id": "paragraph_1591521817161_1552098115",
      "dateCreated": "2020-06-09T16:10:16+0000",
      "status": "READY",
      "$$hashKey": "object:30409"
    },
    {
      "text": "%cassandra\r\n\r\nCREATE KEYSPACE test\r\n WITH REPLICATION=\r\n {'class':'SimpleStrategy', 'replication_factor':1};\r\n \r\n USE test;",
      "user": "anonymous",
      "dateUpdated": "2020-06-09T16:15:32+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591719016918_-1053955389",
      "id": "paragraph_1591523506866_-1291389280",
      "dateCreated": "2020-06-09T16:10:16+0000",
      "status": "READY",
      "$$hashKey": "object:30410"
    },
    {
      "text": "CREATE TABLE stock_symbol (\nsymbol varchar PRIMARY KEY,\ndescription varchar,\nexchange varchar\n);\n\nCREATE TABLE stock_ticker (\nsymbol varchar,\ntick_date varchar,\nopen decimal,\nhigh decimal,\nlow decimal,\nclose decimal,\nvolume bigint,\nPRIMARY KEY (symbol, tick_date)\n);\n",
      "user": "anonymous",
      "dateUpdated": "2020-06-09T16:11:01+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": false,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591719016918_299342744",
      "id": "paragraph_1591523821708_-600802886",
      "dateCreated": "2020-06-09T16:10:16+0000",
      "status": "READY",
      "$$hashKey": "object:30411"
    },
    {
      "text": "%md\nConsider the following three cases: first, we want to list out all\nstocks and their description in all exchanges. The SQL query for this is\nvery simple:\n\n\n``` {.programlisting .language-markup}\n// Query A\nSELECT symbol, description, exchange\nFROM stock_symbol;\n```\n\nSecond, if we want to know all the daily close\nprices and descriptions of the stocks listed in the `NASDAQ`\nexchange, we can write a SQL query as:\n\n\n``` {.programlisting .language-markup}\n// Query B\nSELECT stock_symbol.symbol, stock_symbol.description,\nstock_ticker.tick_date, stock_ticker.close\nFROM stock_symbol, stock_ticker\nWHERE stock_symbol.symbol = stock_ticker.symbol\nAND stock_symbol.exchange = ''NASDAQ'';\n```\n\nFurthermore, if we want to know all the day close prices and\ndescriptions of the stocks listed in the `NASDAQ` exchange on\nApril 24, 2014, we can use the following SQL query:\n\n\n``` {.programlisting .language-markup}\n// Query C\nSELECT stock_symbol.symbol, stock_symbol.description,\nstock_ticker.tick_date, stock_ticker.open,\nstock_ticker.high, stock_ticker.low, stock_ticker_close,\nstock_ticker.volume\nFROM stock_symbol, stock_ticker\nWHERE stock_symbol.symbol = stock_ticker.symbol\nAND stock_symbol.exchange = ''NASDAQ''\nAND stock_ticker.tick_date = ''2014-04-24'';\n```\n\nBy virtue of the relational data model, we can simply write different\nSQL queries to return different results with no changes to the\nunderlying data model at all.\n\n\n",
      "user": "anonymous",
      "dateUpdated": "2020-06-09T16:10:16+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Consider the following three cases: first, we want to list out all<br />\nstocks and their description in all exchanges. The SQL query for this is<br />\nvery simple:</p>\n<pre><code class=\"language-{.programlisting\">// Query A\nSELECT symbol, description, exchange\nFROM stock_symbol;\n</code></pre>\n<p>Second, if we want to know all the daily close<br />\nprices and descriptions of the stocks listed in the <code>NASDAQ</code><br />\nexchange, we can write a SQL query as:</p>\n<pre><code class=\"language-{.programlisting\">// Query B\nSELECT stock_symbol.symbol, stock_symbol.description,\nstock_ticker.tick_date, stock_ticker.close\nFROM stock_symbol, stock_ticker\nWHERE stock_symbol.symbol = stock_ticker.symbol\nAND stock_symbol.exchange = ''NASDAQ'';\n</code></pre>\n<p>Furthermore, if we want to know all the day close prices and<br />\ndescriptions of the stocks listed in the <code>NASDAQ</code> exchange on<br />\nApril 24, 2014, we can use the following SQL query:</p>\n<pre><code class=\"language-{.programlisting\">// Query C\nSELECT stock_symbol.symbol, stock_symbol.description,\nstock_ticker.tick_date, stock_ticker.open,\nstock_ticker.high, stock_ticker.low, stock_ticker_close,\nstock_ticker.volume\nFROM stock_symbol, stock_ticker\nWHERE stock_symbol.symbol = stock_ticker.symbol\nAND stock_symbol.exchange = ''NASDAQ''\nAND stock_ticker.tick_date = ''2014-04-24'';\n</code></pre>\n<p>By virtue of the relational data model, we can simply write different<br />\nSQL queries to return different results with no changes to the<br />\nunderlying data model at all.</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591719016918_-26814004",
      "id": "paragraph_1591523890786_-682448678",
      "dateCreated": "2020-06-09T16:10:16+0000",
      "status": "READY",
      "$$hashKey": "object:30412"
    },
    {
      "text": "SELECT symbol, description, exchange\nFROM stock_symbol;",
      "user": "anonymous",
      "dateUpdated": "2020-06-09T16:10:16+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591719016918_-1231393537",
      "id": "paragraph_1591523517667_-339276940",
      "dateCreated": "2020-06-09T16:10:16+0000",
      "status": "READY",
      "$$hashKey": "object:30413"
    },
    {
      "text": "%md\n### Cassandra version\n\n\nNow let us turn to Cassandra. The DDL statements in\nthe last section can be slightly modified to create column families, or\ntables, in Cassandra, which are as follows:\n\n\n``` {.programlisting .language-markup}\nCREATE TABLE stock_symbol (\nsymbol varchar PRIMARY KEY,\ndescription varchar,\nexchange varchar\n);\n\nCREATE TABLE stock_ticker (\nsymbol varchar,\ntick_date varchar,\nopen decimal,\nhigh decimal,\nlow decimal,\nclose decimal,\nvolume bigint,\nPRIMARY KEY (symbol, tick_date)\n);\n```",
      "user": "anonymous",
      "dateUpdated": "2020-06-09T16:10:16+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h3>Cassandra version</h3>\n<p>Now let us turn to Cassandra. The DDL statements in<br />\nthe last section can be slightly modified to create column families, or<br />\ntables, in Cassandra, which are as follows:</p>\n<pre><code class=\"language-{.programlisting\">CREATE TABLE stock_symbol (\nsymbol varchar PRIMARY KEY,\ndescription varchar,\nexchange varchar\n);\n\nCREATE TABLE stock_ticker (\nsymbol varchar,\ntick_date varchar,\nopen decimal,\nhigh decimal,\nlow decimal,\nclose decimal,\nvolume bigint,\nPRIMARY KEY (symbol, tick_date)\n);\n</code></pre>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591719016919_-850750488",
      "id": "paragraph_1591523683529_-1179137339",
      "dateCreated": "2020-06-09T16:10:16+0000",
      "status": "READY",
      "$$hashKey": "object:30416"
    },
    {
      "text": "CREATE KEYSPACE test2\r\n WITH REPLICATION=\r\n {'class':'SimpleStrategy', 'replication_factor':1};\r\n \r\nUSE test2;",
      "user": "anonymous",
      "dateUpdated": "2020-06-09T16:11:25+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591719016919_-1709629694",
      "id": "paragraph_1591523644346_-1000128063",
      "dateCreated": "2020-06-09T16:10:16+0000",
      "status": "READY",
      "$$hashKey": "object:30415",
      "focus": true
    },
    {
      "text": "CREATE TABLE stock_symbol (\nsymbol varchar PRIMARY KEY,\ndescription varchar,\nexchange varchar\n);\n",
      "user": "anonymous",
      "dateUpdated": "2020-06-09T16:11:58+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": false,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591719016919_-2145360287",
      "id": "paragraph_1591523936786_-1440273142",
      "dateCreated": "2020-06-09T16:10:16+0000",
      "status": "READY",
      "$$hashKey": "object:30417"
    },
    {
      "user": "anonymous",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/text"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591719120752_-770504267",
      "id": "paragraph_1591719120752_-770504267",
      "dateCreated": "2020-06-09T16:12:00+0000",
      "status": "READY",
      "focus": true,
      "$$hashKey": "object:31289",
      "text": "\nCREATE TABLE stock_ticker (\nsymbol varchar,\ntick_date varchar,\nopen decimal,\nhigh decimal,\nlow decimal,\nclose decimal,\nvolume bigint,\nPRIMARY KEY (symbol, tick_date)\n);\n",
      "dateUpdated": "2020-06-09T16:12:06+0000"
    },
    {
      "text": "%md\n\nThey seem to be correct at first sight.\n\nAs for `Query A` , we can query the Cassandra\n`stock_symbol` table exactly the same way:\n\n\n``` {.programlisting .language-markup}\n// Query A\nSELECT symbol, description, exchange\nFROM stock_symbol;\n```\n\nThe following figure depicts the logical and physical storage views of\nthe `stock_symbol `table:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_02_07.jpg)\n\n:::\nThe Cassandra data model for Query A\n:::\n\nThe primary key of the `stock_symbol`\ntable involves only one single column, `symbol` , which is also\nused as the row key and partition key of the column family. We can\nconsider the `stock_symbol` table in terms of the SortedMap\ndata structure mentioned in the previous section:\n\n\n``` {.programlisting .language-markup}\nMap<RowKey, SortedMap<ColumnKey, ColumnValue>>\n```\n\nThe assigned values are as follows:\n\n\n``` {.programlisting .language-markup}\nRowKey=AAPL\nColumnKey=description\nColumnValue=Apple Inc.\nColumnKey=exchange\nColumnValue=NASDAQ\n```\n\nSo far so good, right?\n\nHowever, without foreign keys and joins, how can we obtain the same\nresults for `Query B` and `Query C` in Cassandra? It\nindeed highlights that we need another way to do so. The short answer is\nto use denormalization.\n\nFor `Query B` , what we want is all the day close prices and\ndescriptions of the stocks listed in the `NASDAQ` exchange.\nThe columns involved are `symbol` , `description` ,\n`tick_date` , `close` , and `exchange`. The\nfirst four columns are obvious, but why do we need the\n`exchange` column? The `exchange` column is\nnecessary because it is used as a filter for the query. Another\nimplication is that the `exchange` column is required to be\nthe row key, or at least part of the row key.\n\nRemember two rules:\n\n\n1.  A row key is regarded as a partition key to locate the nodes storing\n    that row\n\n2.  A row cannot be split across two nodes\n:::\n\nIn a distributed system backed by Cassandra, we\nshould minimize unnecessary network traffic as much as possible. In\nother words, the lesser the number of nodes the query needs to work\nwith, the better the performance of the data model. We must cater to the\ncluster topology as well as the physical storage of the data model.\n\nTherefore we should create a column family for `Query B`\nsimilar to the previous one:\n\n\n``` {.programlisting .language-markup}\n// Query B\nCREATE TABLE stock_ticker_by_exchange (\nexchange varchar,\nsymbol varchar,\ndescription varchar,\ntick_date varchar,\nclose decimal,\nPRIMARY KEY (exchange, symbol, tick_date)\n);\n```\n\nThe logical and physical storage views of\n`stock_ticker_by_exchange` are shown as follows:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_02_08.jpg)\n\n:::\nThe Cassandra data model for Query B\n:::\n\nThe row key is  the `exchange` column.\nHowever, this time, it is very strange that the column keys are no\nlonger `symbol` , `tick_date` , `close` , and\n`description`. There are now 12 columns including\n`APPL:2014-04-24:` , `APPL:2014-04-24:close` ,\n`APPL:2014-04-24:description` , `APPL:2014-04-25:` ,\n`APPL:2014-04-25:close` ,\n`APPL:2014-04-25:description` , `FB:2014-04-24:` ,\n`FB:2014-04-24:close` , `FB:2014-04-24:description` ,\n`FB:2014-04-25:` , `FB:2014-04-25:close` , and\n`FB:2014-04-25:description` , respectively. Most importantly,\nthe column keys are now dynamic and are able to store data in just a\nsingle row. The row of this dynamic usage is called a wide row, in\ncontrast to the row containing static columns of the\n`stock_symbol` table---termed as a skinny row.\n\nWhether a column family stores a skinny row or a wide row depends on how\nthe primary key is defined.\n\n\n### Note\n\nIf the primary key contains only one column, the row is a skinny row.\n\nIf the primary key contains more than one column, it is called a\ncompound primary key and the row is a wide row.\n\nIn either case, the first column in the primary key\ndefinition is the row key.\n\nFinally, we come to `Query C`. Similarly, we make use of\ndenormalization. `Query C` differs from `Query B` by\nan additional date filter on April 24, 2014. You might think of reusing\nthe `stock_ticker_by_exchange` table for `Query C`.\nThe answer is wrong. Why? The clue is the primary key which is composed\nof three columns, `exchange` , `symbol` , and\n`tick_date` , respectively. If you look carefully at the column\nkeys of the `stock_ticker_by_exchange` table, you find that\nthe column keys are dynamic as a result of the `symbol` and\n`tick_date` columns. Hence, is it possible for Cassandra to\ndetermine the column keys without knowing exactly which symbols you\nwant? Negative.\n\nA suitable column family for `Query C` should resemble the\nfollowing code:\n\n\n``` {.programlisting .language-markup}\n// Query C\nCREATE TABLE stock_ticker_by_exchange_date (\nexchange varchar,\nsymbol varchar,\ndescription varchar,\ntick_date varchar,\nclose decimal,\nPRIMARY KEY ((exchange, tick_date), symbol)\n);\n```\n\nThis time you should be aware of the definition of the primary key. It\nis interesting that there is an additional pair of parentheses for the\n`exchange` and `tick_date` columns. Let's look at\nthe logical and physical storage views of\n`stock_ticker_by_exchange_date` , as shown in the following\nfigure:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_02_09.jpg)\n\n:::\nThe Cassandra data model for Query C\n:::\n\nYou should pay attention to the number of column\nkeys here. It is only six instead of 12 as in\n`stock_ticker_by_exchange` for `Query B`. The column\nkeys are still dynamic according to the `symbol` column but\nthe row key is now `NASDAQ:2014-04-24` instead of just\n`NASDAQ` in `Query B`. Do you remember the\npreviously mentioned additional pair of parentheses? If you define a\nprimary key in that way, you intend to use more than one column to be\nthe row key and the partition key. It is called a composite partition\nkey. For the time being, it is enough for you to know the terminology\nonly. Further information will be given in later labs.\n\nUntil now, you might have felt dizzy and uncomfortable, especially for\nthose of you having so many years of expertise in the relational data\nmodel. I also found the Cassandra data model very difficult to\ncomprehend at the first time. However, you should be aware of the subtle\ndifferences between a relational data model and Cassandra data model.\nYou must also be very cautious of the query that you handle. A query is\nalways the starting point of designing a Cassandra data model. As an\nanalogy, a query is a question and the data model is the answer. You\nmerely use the data model to answer the query. It is exactly what\nmodeling by query means.\n\n\n",
      "user": "anonymous",
      "dateUpdated": "2020-06-09T16:14:24+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>They seem to be correct at first sight.</p>\n<p>As for <code>Query A</code> , we can query the Cassandra<br />\n<code>stock_symbol</code> table exactly the same way:</p>\n<pre><code class=\"language-{.programlisting\">// Query A\nSELECT symbol, description, exchange\nFROM stock_symbol;\n</code></pre>\n<p>The following figure depicts the logical and physical storage views of<br />\nthe <code>stock_symbol</code>table:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_02_07.jpg\" alt=\"\" /></p>\n<p>:::<br />\nThe Cassandra data model for Query A<br />\n:::</p>\n<p>The primary key of the <code>stock_symbol</code><br />\ntable involves only one single column, <code>symbol</code> , which is also<br />\nused as the row key and partition key of the column family. We can<br />\nconsider the <code>stock_symbol</code> table in terms of the SortedMap<br />\ndata structure mentioned in the previous section:</p>\n<pre><code class=\"language-{.programlisting\">Map&lt;RowKey, SortedMap&lt;ColumnKey, ColumnValue&gt;&gt;\n</code></pre>\n<p>The assigned values are as follows:</p>\n<pre><code class=\"language-{.programlisting\">RowKey=AAPL\nColumnKey=description\nColumnValue=Apple Inc.\nColumnKey=exchange\nColumnValue=NASDAQ\n</code></pre>\n<p>So far so good, right?</p>\n<p>However, without foreign keys and joins, how can we obtain the same<br />\nresults for <code>Query B</code> and <code>Query C</code> in Cassandra? It<br />\nindeed highlights that we need another way to do so. The short answer is<br />\nto use denormalization.</p>\n<p>For <code>Query B</code> , what we want is all the day close prices and<br />\ndescriptions of the stocks listed in the <code>NASDAQ</code> exchange.<br />\nThe columns involved are <code>symbol</code> , <code>description</code> ,<br />\n<code>tick_date</code> , <code>close</code> , and <code>exchange</code>. The<br />\nfirst four columns are obvious, but why do we need the<br />\n<code>exchange</code> column? The <code>exchange</code> column is<br />\nnecessary because it is used as a filter for the query. Another<br />\nimplication is that the <code>exchange</code> column is required to be<br />\nthe row key, or at least part of the row key.</p>\n<p>Remember two rules:</p>\n<ol>\n<li>\n<p>A row key is regarded as a partition key to locate the nodes storing<br />\nthat row</p>\n</li>\n<li>\n<p>A row cannot be split across two nodes<br />\n:::</p>\n</li>\n</ol>\n<p>In a distributed system backed by Cassandra, we<br />\nshould minimize unnecessary network traffic as much as possible. In<br />\nother words, the lesser the number of nodes the query needs to work<br />\nwith, the better the performance of the data model. We must cater to the<br />\ncluster topology as well as the physical storage of the data model.</p>\n<p>Therefore we should create a column family for <code>Query B</code><br />\nsimilar to the previous one:</p>\n<pre><code class=\"language-{.programlisting\">// Query B\nCREATE TABLE stock_ticker_by_exchange (\nexchange varchar,\nsymbol varchar,\ndescription varchar,\ntick_date varchar,\nclose decimal,\nPRIMARY KEY (exchange, symbol, tick_date)\n);\n</code></pre>\n<p>The logical and physical storage views of<br />\n<code>stock_ticker_by_exchange</code> are shown as follows:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_02_08.jpg\" alt=\"\" /></p>\n<p>:::<br />\nThe Cassandra data model for Query B<br />\n:::</p>\n<p>The row key is  the <code>exchange</code> column.<br />\nHowever, this time, it is very strange that the column keys are no<br />\nlonger <code>symbol</code> , <code>tick_date</code> , <code>close</code> , and<br />\n<code>description</code>. There are now 12 columns including<br />\n<code>APPL:2014-04-24:</code> , <code>APPL:2014-04-24:close</code> ,<br />\n<code>APPL:2014-04-24:description</code> , <code>APPL:2014-04-25:</code> ,<br />\n<code>APPL:2014-04-25:close</code> ,<br />\n<code>APPL:2014-04-25:description</code> , <code>FB:2014-04-24:</code> ,<br />\n<code>FB:2014-04-24:close</code> , <code>FB:2014-04-24:description</code> ,<br />\n<code>FB:2014-04-25:</code> , <code>FB:2014-04-25:close</code> , and<br />\n<code>FB:2014-04-25:description</code> , respectively. Most importantly,<br />\nthe column keys are now dynamic and are able to store data in just a<br />\nsingle row. The row of this dynamic usage is called a wide row, in<br />\ncontrast to the row containing static columns of the<br />\n<code>stock_symbol</code> table&mdash;termed as a skinny row.</p>\n<p>Whether a column family stores a skinny row or a wide row depends on how<br />\nthe primary key is defined.</p>\n<h3>Note</h3>\n<p>If the primary key contains only one column, the row is a skinny row.</p>\n<p>If the primary key contains more than one column, it is called a<br />\ncompound primary key and the row is a wide row.</p>\n<p>In either case, the first column in the primary key<br />\ndefinition is the row key.</p>\n<p>Finally, we come to <code>Query C</code>. Similarly, we make use of<br />\ndenormalization. <code>Query C</code> differs from <code>Query B</code> by<br />\nan additional date filter on April 24, 2014. You might think of reusing<br />\nthe <code>stock_ticker_by_exchange</code> table for <code>Query C</code>.<br />\nThe answer is wrong. Why? The clue is the primary key which is composed<br />\nof three columns, <code>exchange</code> , <code>symbol</code> , and<br />\n<code>tick_date</code> , respectively. If you look carefully at the column<br />\nkeys of the <code>stock_ticker_by_exchange</code> table, you find that<br />\nthe column keys are dynamic as a result of the <code>symbol</code> and<br />\n<code>tick_date</code> columns. Hence, is it possible for Cassandra to<br />\ndetermine the column keys without knowing exactly which symbols you<br />\nwant? Negative.</p>\n<p>A suitable column family for <code>Query C</code> should resemble the<br />\nfollowing code:</p>\n<pre><code class=\"language-{.programlisting\">// Query C\nCREATE TABLE stock_ticker_by_exchange_date (\nexchange varchar,\nsymbol varchar,\ndescription varchar,\ntick_date varchar,\nclose decimal,\nPRIMARY KEY ((exchange, tick_date), symbol)\n);\n</code></pre>\n<p>This time you should be aware of the definition of the primary key. It<br />\nis interesting that there is an additional pair of parentheses for the<br />\n<code>exchange</code> and <code>tick_date</code> columns. Let&rsquo;s look at<br />\nthe logical and physical storage views of<br />\n<code>stock_ticker_by_exchange_date</code> , as shown in the following<br />\nfigure:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_02_09.jpg\" alt=\"\" /></p>\n<p>:::<br />\nThe Cassandra data model for Query C<br />\n:::</p>\n<p>You should pay attention to the number of column<br />\nkeys here. It is only six instead of 12 as in<br />\n<code>stock_ticker_by_exchange</code> for <code>Query B</code>. The column<br />\nkeys are still dynamic according to the <code>symbol</code> column but<br />\nthe row key is now <code>NASDAQ:2014-04-24</code> instead of just<br />\n<code>NASDAQ</code> in <code>Query B</code>. Do you remember the<br />\npreviously mentioned additional pair of parentheses? If you define a<br />\nprimary key in that way, you intend to use more than one column to be<br />\nthe row key and the partition key. It is called a composite partition<br />\nkey. For the time being, it is enough for you to know the terminology<br />\nonly. Further information will be given in later labs.</p>\n<p>Until now, you might have felt dizzy and uncomfortable, especially for<br />\nthose of you having so many years of expertise in the relational data<br />\nmodel. I also found the Cassandra data model very difficult to<br />\ncomprehend at the first time. However, you should be aware of the subtle<br />\ndifferences between a relational data model and Cassandra data model.<br />\nYou must also be very cautious of the query that you handle. A query is<br />\nalways the starting point of designing a Cassandra data model. As an<br />\nanalogy, a query is a question and the data model is the answer. You<br />\nmerely use the data model to answer the query. It is exactly what<br />\nmodeling by query means.</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591719016919_-2025263568",
      "id": "paragraph_1591524050305_1689205810",
      "dateCreated": "2020-06-09T16:10:16+0000",
      "status": "FINISHED",
      "$$hashKey": "object:30418",
      "dateFinished": "2020-06-09T16:14:12+0000",
      "dateStarted": "2020-06-09T16:14:12+0000"
    },
    {
      "text": "// Query A\r\nSELECT symbol, description, exchange\r\nFROM stock_symbol;",
      "user": "anonymous",
      "dateUpdated": "2020-06-09T16:12:37+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591719016920_1038972313",
      "id": "paragraph_1591523712750_-665048912",
      "dateCreated": "2020-06-09T16:10:16+0000",
      "status": "READY",
      "$$hashKey": "object:30419"
    },
    {
      "user": "anonymous",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/text"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591719163470_2080246953",
      "id": "paragraph_1591719163470_2080246953",
      "dateCreated": "2020-06-09T16:12:43+0000",
      "status": "READY",
      "focus": true,
      "$$hashKey": "object:31449",
      "text": "// Query B\nCREATE TABLE stock_ticker_by_exchange (\nexchange varchar,\nsymbol varchar,\ndescription varchar,\ntick_date varchar,\nclose decimal,\nPRIMARY KEY (exchange, symbol, tick_date)\n);",
      "dateUpdated": "2020-06-09T16:13:11+0000"
    },
    {
      "user": "anonymous",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/text"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591719152713_1854069412",
      "id": "paragraph_1591719152713_1854069412",
      "dateCreated": "2020-06-09T16:12:32+0000",
      "status": "ERROR",
      "focus": true,
      "$$hashKey": "object:31380",
      "text": "// Query C\r\nCREATE TABLE stock_ticker_by_exchange_date (\r\nexchange varchar,\r\nsymbol varchar,\r\ndescription varchar,\r\ntick_date varchar,\r\nclose decimal,\r\nPRIMARY KEY ((exchange, tick_date), symbol)\r\n);",
      "dateUpdated": "2020-06-09T16:14:53+0000",
      "dateFinished": "2020-06-09T16:14:53+0000",
      "dateStarted": "2020-06-09T16:14:53+0000"
    },
    {
      "user": "anonymous",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/text",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591719192891_1931296502",
      "id": "paragraph_1591719192891_1931296502",
      "dateCreated": "2020-06-09T16:13:12+0000",
      "status": "FINISHED",
      "focus": true,
      "$$hashKey": "object:31525",
      "text": "%md\n\n\nData modeling considerations\n----------------------------------------------\n\n\n\nApart from modeling by query, we need to bear in\nmind a few important points when designing a Cassandra data model. We\ncan also consider a few good patterns that will be introduced in this\nsection.\n\n\n\n### Data duplication\n\n\nDenormalization is  an evil in a \nrelational data model, but not in Cassandra. Indeed, it is a\ngood and common practice. It is solely based on the\nfact that Cassandra does not use high-end disk storage subsystem.\nCassandra loves commodity-grade hard drives, and hence disk space is\ncheap. Data duplication as a result of denormalization is by no means a\nproblem anymore; Cassandra welcomes it.\n\n\n### Sorting\n\n\nIn a relational database, sorting \ncan be easily controlled using the `ORDER BY`\nclause in a SQL query. Alternatively, a secondary index can be created\nto further speed up the sorting operations.\n\nIn Cassandra, however, sorting is by design because you must determine\nhow to compare data for a column family at the time of its creation. The\ncomparator of the column family dictates how the rows are ordered on\nreads. Additionally, columns are ordered by their column names, also by\na comparator.\n\n\n### Wide row\n\n\nIt is common to use wide rows for \nordering, grouping and efficient filtering. Besides, you can\nuse skinny rows. All you have to consider is the number of columns the\nrow contains.\n\nIt is worth noting that for a column family storing skinny rows, the\ncolumn key is repeatedly stored in each column. Although it wastes some\nstorage space, it is not a problem on inexpensive commodity hard disks.\n\n\n### Bucketing\n\n\nEven though a wide row can \naccommodate up to 2 billion variable columns, it is still a\nhard limit that cannot prevent voluminous data from filling up a node.\nIn order to break through the 2 billion column limit, we can use a\nworkaround technique called bucketing to split the data across multiple\nnodes.\n\nBucketing requires the client application to\ngenerate a bucket ID, which is often a random \nnumber. By including the bucket ID into a composite partition\nkey, you can break up and distribute segments of the data to different\nnodes. However, it should not be abused. Breaking up the data across\nmultiple nodes causes reading operations to consume extra resources to\nmerge and reorder data. Thus, it is expensive and not a favorable\nmethod, and therefore should only be a last resort.\n\n\n### Valueless column\n\n\nColumn keys can store values as shown in\n the *Modeling by query* section. There is no\n\\\"Not Null\\\" concept in Cassandra such that column values can store\nempty values without any problem. Simply storing data in column keys\nwhile leaving empty values in the column, known as a valueless column,\nis sometimes used purposely. It's a common practice with Cassandra.\n\nOne motivation for valueless columns is the sort-by-column-key feature\nof Cassandra. Nonetheless, there are some limitations and caveats. The\nmaximum size of a column key is 64 KB, in contrast to 2 GB for a column\nvalue. Therefore, space in a column key is limited. Furthermore, using\ntimestamp alone as a column key can result in timestamp collision.\n\n\n### Time-series data\n\n\nWhat is time-series data? It is \n anything that varies on a temporal basis such as processor\nutilization, sensor data, clickstream, and stock ticker. The stock quote\ndata model introduced earlier is one such example. Cassandra is a\nperfect fit for storing time-series data. Why? Because one row can hold\nas many as 2 billion variable columns. It is a single layout on disk,\nbased on the storage model. Therefore, Cassandra can handle voluminous\ntime-series data in a blazing fast fashion. TTL is another excellent\nfeature to simplify data housekeeping.\n\nIn the second half of this course, a complete stock quote technical\nanalysis application will be developed to further explain the details of\nusing Cassandra to handle time-series data.\n\n\n\nCassandra Query Language\n------------------------------------------\n\n\n\nIt is quite common for other authors to start\nintroducing the Cassandra data model from CQL. I use a different\napproach in this lab. I try to avoid diving too deep in CQL before\nwe have a firm understanding of how Cassandra handles its physical\nstorage.\n\nThe syntax of CQL is designed to be very similar to that of SQL. This\nintent is good for someone who is used to writing SQL statements in the\nrelational world, to migrate to Cassandra. However, because of the high\ndegree of similarity between CQL and SQL, it is even more difficult for\nus to throw away the relational mindsets if CQL is used to explain how\nto model data in Cassandra. It might cause more confusion in the end. I\nprefer the approach of a microscopic view of how the data model relates\nto the physical storage. By doing so, you can grasp the key points more\nquickly and understand the inner working mechanism more clearly. CQL is\ncovered extensively in the next lab.\n\n\n\nSummary\n-------------------------\n\n\n\nIn this lab, we looked at the basics of a Cassandra data model and\nare now familiar with the column, row, column family, keyspace, counter,\nand other related terms. A comparison of the main differences between a\nrelational data model and the Cassandra data model was also given to\nexplain the concept of modeling by query that may seem shocking and\ncounterintuitive at first sight. Then a few important considerations on\ndata modeling and typical usage patterns were introduced. Finally, the\nreason why the introduction of CQL is deliberately postponed was\nexpressed.\n\nThis lab is only the first part on Cassandra data modeling. In the\nnext lab, we will continue the second part of the tour, Cassandra\nQuery Language.",
      "dateUpdated": "2020-06-09T16:15:06+0000",
      "dateFinished": "2020-06-09T16:15:06+0000",
      "dateStarted": "2020-06-09T16:15:06+0000",
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h2>Data modeling considerations</h2>\n<p>Apart from modeling by query, we need to bear in<br />\nmind a few important points when designing a Cassandra data model. We<br />\ncan also consider a few good patterns that will be introduced in this<br />\nsection.</p>\n<h3>Data duplication</h3>\n<p>Denormalization is  an evil in a<br />\nrelational data model, but not in Cassandra. Indeed, it is a<br />\ngood and common practice. It is solely based on the<br />\nfact that Cassandra does not use high-end disk storage subsystem.<br />\nCassandra loves commodity-grade hard drives, and hence disk space is<br />\ncheap. Data duplication as a result of denormalization is by no means a<br />\nproblem anymore; Cassandra welcomes it.</p>\n<h3>Sorting</h3>\n<p>In a relational database, sorting<br />\ncan be easily controlled using the <code>ORDER BY</code><br />\nclause in a SQL query. Alternatively, a secondary index can be created<br />\nto further speed up the sorting operations.</p>\n<p>In Cassandra, however, sorting is by design because you must determine<br />\nhow to compare data for a column family at the time of its creation. The<br />\ncomparator of the column family dictates how the rows are ordered on<br />\nreads. Additionally, columns are ordered by their column names, also by<br />\na comparator.</p>\n<h3>Wide row</h3>\n<p>It is common to use wide rows for<br />\nordering, grouping and efficient filtering. Besides, you can<br />\nuse skinny rows. All you have to consider is the number of columns the<br />\nrow contains.</p>\n<p>It is worth noting that for a column family storing skinny rows, the<br />\ncolumn key is repeatedly stored in each column. Although it wastes some<br />\nstorage space, it is not a problem on inexpensive commodity hard disks.</p>\n<h3>Bucketing</h3>\n<p>Even though a wide row can<br />\naccommodate up to 2 billion variable columns, it is still a<br />\nhard limit that cannot prevent voluminous data from filling up a node.<br />\nIn order to break through the 2 billion column limit, we can use a<br />\nworkaround technique called bucketing to split the data across multiple<br />\nnodes.</p>\n<p>Bucketing requires the client application to<br />\ngenerate a bucket ID, which is often a random<br />\nnumber. By including the bucket ID into a composite partition<br />\nkey, you can break up and distribute segments of the data to different<br />\nnodes. However, it should not be abused. Breaking up the data across<br />\nmultiple nodes causes reading operations to consume extra resources to<br />\nmerge and reorder data. Thus, it is expensive and not a favorable<br />\nmethod, and therefore should only be a last resort.</p>\n<h3>Valueless column</h3>\n<p>Column keys can store values as shown in<br />\nthe <em>Modeling by query</em> section. There is no<br />\n&quot;Not Null&quot; concept in Cassandra such that column values can store<br />\nempty values without any problem. Simply storing data in column keys<br />\nwhile leaving empty values in the column, known as a valueless column,<br />\nis sometimes used purposely. It&rsquo;s a common practice with Cassandra.</p>\n<p>One motivation for valueless columns is the sort-by-column-key feature<br />\nof Cassandra. Nonetheless, there are some limitations and caveats. The<br />\nmaximum size of a column key is 64 KB, in contrast to 2 GB for a column<br />\nvalue. Therefore, space in a column key is limited. Furthermore, using<br />\ntimestamp alone as a column key can result in timestamp collision.</p>\n<h3>Time-series data</h3>\n<p>What is time-series data? It is<br />\nanything that varies on a temporal basis such as processor<br />\nutilization, sensor data, clickstream, and stock ticker. The stock quote<br />\ndata model introduced earlier is one such example. Cassandra is a<br />\nperfect fit for storing time-series data. Why? Because one row can hold<br />\nas many as 2 billion variable columns. It is a single layout on disk,<br />\nbased on the storage model. Therefore, Cassandra can handle voluminous<br />\ntime-series data in a blazing fast fashion. TTL is another excellent<br />\nfeature to simplify data housekeeping.</p>\n<p>In the second half of this course, a complete stock quote technical<br />\nanalysis application will be developed to further explain the details of<br />\nusing Cassandra to handle time-series data.</p>\n<h2>Cassandra Query Language</h2>\n<p>It is quite common for other authors to start<br />\nintroducing the Cassandra data model from CQL. I use a different<br />\napproach in this lab. I try to avoid diving too deep in CQL before<br />\nwe have a firm understanding of how Cassandra handles its physical<br />\nstorage.</p>\n<p>The syntax of CQL is designed to be very similar to that of SQL. This<br />\nintent is good for someone who is used to writing SQL statements in the<br />\nrelational world, to migrate to Cassandra. However, because of the high<br />\ndegree of similarity between CQL and SQL, it is even more difficult for<br />\nus to throw away the relational mindsets if CQL is used to explain how<br />\nto model data in Cassandra. It might cause more confusion in the end. I<br />\nprefer the approach of a microscopic view of how the data model relates<br />\nto the physical storage. By doing so, you can grasp the key points more<br />\nquickly and understand the inner working mechanism more clearly. CQL is<br />\ncovered extensively in the next lab.</p>\n<h2>Summary</h2>\n<p>In this lab, we looked at the basics of a Cassandra data model and<br />\nare now familiar with the column, row, column family, keyspace, counter,<br />\nand other related terms. A comparison of the main differences between a<br />\nrelational data model and the Cassandra data model was also given to<br />\nexplain the concept of modeling by query that may seem shocking and<br />\ncounterintuitive at first sight. Then a few important considerations on<br />\ndata modeling and typical usage patterns were introduced. Finally, the<br />\nreason why the introduction of CQL is deliberately postponed was<br />\nexpressed.</p>\n<p>This lab is only the first part on Cassandra data modeling. In the<br />\nnext lab, we will continue the second part of the tour, Cassandra<br />\nQuery Language.</p>\n\n</div>"
          }
        ]
      }
    },
    {
      "text": "",
      "user": "anonymous",
      "dateUpdated": "2020-06-09T16:15:22+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/scala"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591719306267_-1304640903",
      "id": "paragraph_1591719306267_-1304640903",
      "dateCreated": "2020-06-09T16:15:06+0000",
      "status": "READY",
      "focus": true,
      "$$hashKey": "object:31712"
    }
  ],
  "name": "lab_2",
  "id": "2F9ZQFH26",
  "defaultInterpreterGroup": "spark",
  "version": "0.9.0-preview1",
  "noteParams": {},
  "noteForms": {},
  "angularObjects": {},
  "config": {
    "isZeppelinNotebookCronEnable": false,
    "looknfeel": "default",
    "personalizedMode": "false"
  },
  "info": {},
  "path": "/lab_2"
}