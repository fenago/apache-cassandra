{
  "paragraphs": [
    {
      "text": "%sh\nSTATUS=\"$(service cassandra status)\"\n\nif [[ $STATUS == *\"is running\"* ]]; then\n    echo \"Cassandra is running\"\nelse \n    echo \" Cassandra not running .... Starting\"  \n    service cassandra restart > /dev/null 2>&1 &\n    echo \" Started\"  \nfi",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T11:35:12+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "sh",
          "editOnDblClick": false,
          "completionSupport": false
        },
        "editorMode": "ace/mode/sh"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591529522955_978221772",
      "id": "paragraph_1591529522955_978221772",
      "dateCreated": "2020-06-07T11:32:02+0000",
      "dateStarted": "2020-06-07T11:35:12+0000",
      "dateFinished": "2020-06-07T11:35:12+0000",
      "status": "FINISHED",
      "focus": true,
      "$$hashKey": "object:16712"
    },
    {
      "text": "%md\n\n\n\nLab 4. Indexes\n---------------------------\n\n\nThere is no doubt that Cassandra can store a gigantic volume of data\neffortlessly. However, if we cannot efficiently look for what we want in\nsuch a data abyss, it is meaningless. Cassandra provides very good\nsupport to search and retrieve the desired data by the primary index and\nsecondary index.\n\nIn this lab, we will look at how Cassandra uses the primary index\nand the secondary index to spotlight the data. After developing an\nunderstanding of them, we can then design a high-performance data model.\n\n\n\nPrimary index\n-------------------------------\n\n\n\nCassandra is a column-based database. Each row can have different number\nof columns. A cell is the  placeholder of the value\nand the timestamp data is identified by a row and column. Each cell can\nstore values that are less than 2 GB. The rows are grouped by\npartitions. The maximum number of cells per partition is limited to the\ncondition that the number of rows times the number of columns is less\nthan 2 billion. Each row is identified by a row key that determines\nwhich machine stores the row. In other words, the row key determines the\nnode location of the row. A list of row keys of a table is\nknown as a primary key. A primary index is just\ncreated on the primary key.\n\nA primary key can be defined on a single column or multiple columns. In\neither case, the first component of a table's primary key is the\npartition key. Each node stores a data partition of the table and\nmaintains its own primary key for the data that it manages. Therefore,\neach node knows what ranges of row key it can manage and the rows can\nthen be located by scanning the row indexes only on the relevant\nreplicas. The range of the primary keys that a node manages is\ndetermined by the partition key and a cluster-wide configuration\nparameter called partitioner. Cassandra provides three choices to\npartitioner that will be covered later in this lab.\n\nA primary key can be defined by the CQL keywords\n`PRIMARY KEY` , with the column(s) to be indexed. Imagine that\nwe want to store the daily stock quotes into a Cassandra table called\n`dayquote01`. The `CREATE TABLE` statement creates a\ntable with a simple primary key that involves only one column, as shown\nin the following screenshot:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_01.jpg)\n\nThe `symbol` field is assigned the\nprimary key of the `dayquote01` table. This means that all the\nrows of the same symbol are stored on the same node. Hence, this makes\nthe retrieval of these rows very efficient.\n\nAlternatively, the primary key can be defined by an explicit\n`PRIMARY KEY` clause, as shown in the following screenshot:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_02.jpg)\n\nUnlike relational databases, Cassandra does not enforce a unique\nconstraint on the primary key, as there is no *primary key\nviolation* in Cassandra. An `INSERT` statement\nusing an existing row key is allowed. Therefore, in CQL,\n`INSERT` and `UPDATE` act in the same way, which is\nknown as **UPSERT**. For example, we can\ninsert two records into the table `dayquote01` with the same\nsymbol and no primary key violation is alerted, as shown in the\nfollowing screenshot:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_03.jpg)\n\nThe returned query result contains only one row,\nnot two rows as expected. This is because the primary key is the symbol\nand the row in the latter `INSERT` statement overrode the\nrecord that was created by the former `INSERT` statement.\nThere is no warning for a duplicate primary key. Cassandra simply and\nquietly updated the row. This silent UPSERT behavior might sometimes\ncause undesirable effects in the application logic.\n\n\n### Tip\n\nHence, it is very important for an application developer to handle\nduplicate primary key situations in the application logic. Do not rely\non Cassandra to check the uniqueness for you.\n\nIn fact, the reason why Cassandra behaves like this becomes more clear\nwhen we know how the internal storage engine stores the row, as shown by\nCassandra CLI in the following screenshot:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_04.jpg)\n\nThe row key is `0001.HK`. It is used to\nlocate which node is used to store the row. Whenever we insert or update\nthe row of the same row key, Cassandra blindly locates the row and\nmodifies the columns accordingly, even though an `INSERT`\nstatement has been used.\n\nAlthough a single column primary key is not uncommon, a primary key\ncomposed of more than one column is much more practical.\n\n\n\nCompound primary key and composite partition key\n------------------------------------------------------------------\n\n\n\nA compound primary key is composed of more than one\ncolumn. The order of the columns is important. The\nstructure of a compound primary key is depicted in the following figure:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_05.jpg)\n\nColumns 1 to A are used as the partition key for Cassandra to determine\nthe node location for the partition. The remaining columns, columns B to\nN, are referred to as the clustering columns for the ordering of data.\nThe clustering columns are used to locate a unique record in the data\nnode. They are ordered, by default, and have the ability to use the\n`ORDER BY [DESC]` clause in the `SELECT` statements.\nMoreover, we can get the `MIN` or `MAX` values for\nclustering keys with the `LIMIT 1` clause. We also need to use\nthe clustering columns for the predicates in a\n`WHERE` clause. We cannot leave out one\nwhen trying to build a query.\n\nTo define a compound primary key, an explicit `PRIMARY KEY`\nclause must be used in the `CREATE TABLE` or\n`ALTER TABLE` statements. We can define a compound primary key\nfor the table `dayquote03` , as shown in the following\nscreenshot:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_06.jpg)\n\nBecause the first part of the primary key (that is `symbol`)\nis the same as that of the simple primary key, the partition key is the\nsame as that in `dayquote01`. Therefore, the node location is\nthe same regardless of whether the primary key is compound or not, as in\nthis case.\n\nSo, what is difference between the simple primary key\n(`symbol`) and this compound one\n(`symbol, price_time`)? The additional field\n`price_time` instructs Cassandra to guarantee the clustering\nor ordering of the rows within the partition by the values of\n`price_time`. Thus, the compound primary key sorts the rows of\nthe same symbol by `price_time`. We insert two records into\nthe `dayquote03` table and select all the records to see the\neffect, as shown in the following screenshot:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_07.jpg)\n\nTwo records are returned as expected (compared to\nonly one record in `dayquote01`).\nMoreover, the ordering of the results is sorted by the values of\n`price_time`. The following screenshot shows the internal view\nof the rows in the `dayquote03` table:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_08.jpg)\n\nThe row key is still the partition key, that is,\n`0001.HK`. However, Cassandra stores the two rows returned by\nthe CQL `SELECT` statement, as one single\ninternal row in its storage. The values of the clustering columns are\nused as a prefix to the columns that are not specified in the\n`PRIMARY KEY` clause. As Cassandra stores the internal columns\nin the sorting order of the column name, the rows returned by the CQL\n`SELECT` statement are sorted inherently. In a nutshell, on a\nphysical node, when the rows for a partition key are stored in the order\nthat is based on the clustering columns, the retrieval of rows is very\nefficient.\n\nNow you know that the first part of a compound primary key is the\npartition key. If we need to keep on storing 3,000 daily quotes (around\n10 years) for `0001.HK` , although the CQL `SELECT`\nstatement returns 3,000 virtual rows, Cassandra requires to store these\n3,000 virtual rows as one entire row on a node by the partition key. The\nsize of the entire row gets bigger and bigger on a node as a result of\nstoring more and more daily quotes. The row will quickly become gigantic\nover a period of time and will then pose a serious performance problem,\nas a result of an unbalanced cluster. The solution is a feature offered\nby Cassandra called composite partition key.\n\nThe composite partition key spreads the data over\nmultiple nodes. It is defined by an extra set of\nparentheses in the `PRIMARY KEY` clause. Let us create another\ntable `dayquote04` with a composite partition key in order to\nillustrate the effect. The columns `exchange` and\n`symbol` are now members of a composite partition key, whereas\nthe column `price_time` is a clustering column. We insert the\nsame two records of different symbols into `dayquote04` , as\nshown in the following screenshot:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_09.jpg)\n\nWith reference to the following screenshot, two internal rows are\nreturned with their row keys as `SEHK:0001.HK` and\n`SEHK:0002.HK` , respectively. Internally, Cassandra\nconcatenates the columns in the composite partition key together as an\ninternal row key. In short, the original row without a composite\npartition key is now split into two rows. As the row keys are now\ndifferent from each other, the corresponding rows can be stored on\ndifferent nodes. The value of the clustering column\n`price_time` is still used as a prefix in the internal column\nname to preserve the ordering of data:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_10.jpg)\n\n\n### Time-series data\n\n\nCassandra is  very suitable for handling\ntime-series type of data, such as web server\nlogfiles, usage data, sensor data, SIP packets, and so on. The tables\n`dayquote01` to `dayquote04` in the previous\nsections are used to store the daily stock quotes is an example of the\ntime-series data.\n\nWe have just seen in the last section that a composite partition key is\na better way of not overwhelming the row. It limits the size of the rows\non the basis of a symbol. However, this does partially solve the\nproblem. The size of the row of a symbol still grows over a period of\ntime. Do you have any other suggestion? We can define an artificial\ncolumn, `quote_date` , in the table and set the composite\npartition key to `exchange` and `quote_date`\ninstead, as shown in the following screenshot:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_11.jpg)\n\nNow the composite partition key limits the size\nof the rows on a daily basis, and makes the rows\nmore manageable. This way of doing is analogous to inserting the data\ninto different buckets labeled by a particular\ndate. Hence, it is given a name called the **date bucket\npattern**. Partitioning by the date also makes table\nmaintenance easier by allowing you to drop the partition of\n`quote_date`. One drawback of the date bucket pattern is that\nyou always need to know the partition key in order to get the rows. So,\nin `dayquote05` , you cannot get the latest\n`quote_date` value using the `ORDER BY DESC` and\n`LIMIT 1` clauses.\n\nThe date bucket pattern gives an application developer a design option\nto attain a more balanced cluster, but how balanced a cluster is depends\non a number of factors in which the most important one is the selection\nof the partitioner.\n\n\n\nPartitioner\n-----------------------------\n\n\n\nA partitioner is basically a hash function used to\ncalculate the `TOKEN()` (the hash value) of a row key and so,\nit determines how data is distributed across the nodes in a cluster.\nChoosing a partitioner determines which node is used to place the first\ncopy of data. Each row of data is uniquely identified by a partition key\nand is distributed across the cluster by the value of the\n`TOKEN()`. Cassandra provides the following three\npartitioners:\n\n\n-   `Murmur3Partitioner` (default since version 1.2)\n\n-   `RandomPartitioner` (default before version 1.2)\n\n-   `ByteOrderedPartitioner`\n\n\n### Murmur3Partitioner\n\n\n`Murmur3Partitioner` provides faster\nhashing and improved performance than the\npartitioner `RandomPartitioner`. It is the default\npartitioning strategy and the right choice for new clusters in almost\nall cases. It uses the *MurmurHash* function that creates a\n64-bit hash value of the partition key. The possible range of hash\nvalues is from -2^63^ to +2^63^ -1. When using\n`Murmur3Partitioner` , you can page through all the rows using\nthe `TOKEN()` function in a CQL `SELECT` statement.\n\n\n### RandomPartitioner\n\n\n`RandomPartitioner` was the default\npartitioner prior to Cassandra Version 1.2. It\ndistributes data evenly across the nodes using an *MD5*\nhash value of the row key. The possible range of hash values is from 0\nto 2^127^ -1. The MD5 hash function is slow in performance, that is why\nCassandra has moved to Murmur3 hashes. When using\n`RandomPartitioner` , you can page through all rows using the\n`TOKEN()` function in a CQL `SELECT` statement.\n\n\n### ByteOrderedPartitioner\n\n\n`ByteOrderedPartitioner` , as its name suggests, is used for\nordered partitioning. This partitioner orders rows\nlexically by key bytes. Tokens are calculated by\nlooking at the actual values of the partition key data and using a\nhexadecimal representation of the leading character(s) in a key. For\nexample, if you wanted to partition rows alphabetically, you can assign\na B `TOKEN()` using its hexadecimal representation of\n`0x42`.\n\nUsing `ByteOrderedPartitioner` allows ordered scans by a\nprimary key as though you were moving a cursor through a traditional\nindex in a relational table. This type of range scan query is not\npossible using `RandomPartitioner` because the keys are stored\nin the order of their MD5 hash, and not in the sequential order of the\nkeys.\n\nApparently, performing range-scan on rows sounds like a desirable\nfeature of `ByteOrderedPartitioner`. There are ways to achieve\nthe same functionality using secondary indexes.\nConversely, using `ByteOrderedPartitioner` is not recommended\nfor the following reasons:\n\n\n-   **Difficult load balancing**: More administrative\n    overhead is required to load balance the cluster.\n    `ByteOrderedPartitioner` requires administrators to\n    manually calculate partition ranges based on their estimates of the\n    partition key distribution.\n\n-   **Sequential writes can cause hot spots**: If the\n    application tends to write or update a sequential block of rows at a\n    time, the writes will not be distributed across\n    the cluster. They all go to one node. This is\n    frequently a problem for applications dealing with timestamped data.\n\n-   **Uneven load balancing for multiple tables**: If the\n    application has multiple tables, chances are that these tables have\n    different row keys and different distributions\n    of data. An ordered partitioner that is balanced for one table can\n    cause hot spots and uneven distribution for another table in the\n    same cluster.\n\n\n### Paging and token function\n\n\nWhen using the `RandomPartitioner` or\n`Murmur3Partitioner` , the rows are ordered by the hash of\ntheir value. Hence, the order of the rows is  not\nmeaningful. Using CQL, the rows can still be paged through \neven when using `RandomPartitioner` or\n`Murmur3Partitioner` using the `TOKEN()` function,\nas shown in the following screenshot:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_12.jpg)\n\n`ByteOrderedPartitioner` arranges tokens in the same way as\nkey values, while `RandomPartitioner` and\n`Murmur3Partitioner` distribute tokens in a completely\nunordered manner. The `TOKEN()` function makes it possible to\npage through the unordered partitioner results. It actually queries\nresults directly using tokens.\n\n\n\nSecondary indexes\n-----------------------------------\n\n\n\nAs Cassandra only allows each table to have one\nprimary key, it supports secondary index on columns other than those in\nthe primary key. The benefit is a fast, efficient lookup of data\nmatching the indexed columns in the `WHERE` clause. Each table\ncan have more than one secondary index. Cassandra uses secondary indexes\nto find the rows that are not using the row key. Behind the scenes, the\nsecondary index is implemented as a separate, hidden table that is\nmaintained automatically by the internal process of Cassandra. As with\nrelational databases, keeping secondary indexes up to date is not free,\nso unnecessary indexes should be avoided.\n\n\n### Note\n\nthe between a\nprimary index and a secondary index is that the primary index is a\ndistributed index used to locate the node that stores the row key,\nwhereas the secondary index is a local index just to index the data on\nthe local node.\n\nTherefore, the secondary index will not be able to know immediately the\nlocations of all matched rows without having examined all the nodes in\nthe cluster. This makes the performance of the secondary index\nunpredictable.\n\n\n### Note\n\nThe secondary index is the most efficient when using equality\npredicates. This is indeed a limitation that must have at least one\nequality predicate clause to hopefully limit the set of rows that need\nto be read into memory.\n\nIn addition, the secondary index cannot be created on the primary key\nitself.\n\n\n### Note\n\n**Caveat!**\n\nSecondary indexes in Cassandra are\n*NOT* equivalent to those in the traditional RDBMS. They\nare not akin to a B-tree index in RDBMS. They are mostly like a hash.\nSo, the range queries do not work on secondary indexes in Cassandra,\nonly equality queries work on secondary indexes.\n\nWe can use the CQL `CREATE INDEX` statement to create an index\non a column after we define a table. For example, we might want to add a\ncolumn `sector` to indicate the sector that the stock belongs\nto, as shown in the following screenshot:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_13.jpg)\n\nIf we want to search `dayquote06` for\nsymbols that belong to `Properties` , we might run the command,\nas shown in the following screenshot:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_14.jpg)\n\nAs `sector` is not in the primary key, we cannot query\nCassandra directly by `sector`. Instead, we can create a\nsecondary index on the column `sector` to make this possible,\nas shown in the following screenshot:\n\n\n![](https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_15.jpg)\n\nThe index name `dayquote06_sector_idx` is\noptional, but must be unique within the keyspace. Cassandra assigns a\nname such as `dayquote06_idx` if you do not provide a name. We\ncan now query Cassandra for daily stock quotes by `sector`.\n\nYou can see that the columns in the primary key are not present in the\n`WHERE` predicate clause in the previous screenshot and\nCassandra uses the secondary index to look for the rows matching the\nselection condition.\n\n\n\n### Multiple secondary indexes\n\n\nCassandra supports multiple secondary indexes on a table. The\n`WHERE` clause is executed if at least\none column is involved in a secondary index. Thus,\nwe can use multiple conditions in the\n`WHERE` clause to filter the results. When multiple\noccurrences of data match a condition in the `WHERE` predicate\nclause, Cassandra selects the least frequent occurrence of a condition\nto process first so as to have a better query efficiency.\n\nWhen a potentially expensive query is attempted, such as a range query,\nCassandra requires the `ALLOW FILTERING`\nclause, which can apply additional filters to the result set for values\nof other non-indexed columns. It works very slowly because it scans all\nrows in all nodes. The `ALLOW FILTERING` clause is used to\nexplicitly direct Cassandra to execute that potentially expensive query\non any `WHERE` clause without creating secondary indexes,\ndespite unpredictability of the performance.\n\n\n### Secondary index do's and don'ts\n\n\nThe secondary index is best on a table that has\nmany rows that contain fewer unique values, that is\nlow cardinality in the relational database terminologies, which is\ncounterintuitive to the relational people. The more unique values that\nexist in a particular column, the more overhead you will have to query\nand maintain the index. Hence, it is not suitable for querying a huge\nvolume of records for a small number of results.\n\n\n### Tip\n\nDo index the columns with values that have low cardinality. Cassandra\nstores secondary indexes only for local rows in the\ndata node as a hash-multimap or as bitmap indexes, you can refer to it\nat <https://issues.apache.org/jira/browse/CASSANDRA-1472>.\n\nSecondary indexes should be avoided in the following situations:\n\n\n-   On high-cardinality columns for a small number of results out of a\n    huge volume of rows\n\n    An index on a high-cardinality column will incur many seeks for very\n    few results. For columns containing unique values, using an index\n    for convenience is fine from a performance perspective, as long as\n    the query volume to the indexed column family is moderate and not\n    under constant load.\n\n-   In tables that use a counter column\n\n-   On a frequently updated or deleted column\n\n    Cassandra stores tombstones (a marker in a row that indicates that a\n    column was deleted. During compaction, marked columns are deleted in\n    the index (a hidden table) until the tombstone limit reaches 100 K\n    cells. After exceeding this limit, the query that uses the indexed\n    value will fail.\n\n-   To look for a row in a large partition\n\n    A query on an indexed column in a large cluster typically requires\n    collating responses from multiple data partitions. The query\n    response slows down as more machines get added to the cluster.\n\n\n### Tip\n\n**Important points to take note of**\n\n-   Don't index on high-cardinality columns\n-   Don't use index in tables having a counter\n    column\n-   Don't index on a frequently updated or deleted column\n-   Don't abuse the index to look for a row in a large partition\n\n\n\nSummary\n-------------------------\n\n\n\nWe have learned about the primary and secondary indexes in this lab.\nRelated topics such as compound primary key, composite partition key,\nand partitioner are also introduced. With the help of the explanation of\nthe internal storage and inner working mechanisms of Cassandra, you\nshould now be able to state the difference between the primary index and\nthe secondary index, as well as use them properly in your data model.\n\nIn the next lab, we will start building the first version of the\ntechnical analysis application using Cassandra and Python. A quick\ninstallation and setup guide on how to connect Python to Cassandra and\ncollect market data will also be provided.\n",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T11:40:07+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": false,
        "results": {},
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false
        },
        "editorMode": "ace/mode/text",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591529484449_-1279572451",
      "id": "paragraph_1591529484449_-1279572451",
      "dateCreated": "2020-06-07T11:31:24+0000",
      "dateStarted": "2020-06-07T11:39:56+0000",
      "dateFinished": "2020-06-07T11:39:56+0000",
      "status": "FINISHED",
      "$$hashKey": "object:16713",
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h2>Lab 4. Indexes</h2>\n<p>There is no doubt that Cassandra can store a gigantic volume of data<br />\neffortlessly. However, if we cannot efficiently look for what we want in<br />\nsuch a data abyss, it is meaningless. Cassandra provides very good<br />\nsupport to search and retrieve the desired data by the primary index and<br />\nsecondary index.</p>\n<p>In this lab, we will look at how Cassandra uses the primary index<br />\nand the secondary index to spotlight the data. After developing an<br />\nunderstanding of them, we can then design a high-performance data model.</p>\n<h2>Primary index</h2>\n<p>Cassandra is a column-based database. Each row can have different number<br />\nof columns. A cell is the  placeholder of the value<br />\nand the timestamp data is identified by a row and column. Each cell can<br />\nstore values that are less than 2 GB. The rows are grouped by<br />\npartitions. The maximum number of cells per partition is limited to the<br />\ncondition that the number of rows times the number of columns is less<br />\nthan 2 billion. Each row is identified by a row key that determines<br />\nwhich machine stores the row. In other words, the row key determines the<br />\nnode location of the row. A list of row keys of a table is<br />\nknown as a primary key. A primary index is just<br />\ncreated on the primary key.</p>\n<p>A primary key can be defined on a single column or multiple columns. In<br />\neither case, the first component of a table&rsquo;s primary key is the<br />\npartition key. Each node stores a data partition of the table and<br />\nmaintains its own primary key for the data that it manages. Therefore,<br />\neach node knows what ranges of row key it can manage and the rows can<br />\nthen be located by scanning the row indexes only on the relevant<br />\nreplicas. The range of the primary keys that a node manages is<br />\ndetermined by the partition key and a cluster-wide configuration<br />\nparameter called partitioner. Cassandra provides three choices to<br />\npartitioner that will be covered later in this lab.</p>\n<p>A primary key can be defined by the CQL keywords<br />\n<code>PRIMARY KEY</code> , with the column(s) to be indexed. Imagine that<br />\nwe want to store the daily stock quotes into a Cassandra table called<br />\n<code>dayquote01</code>. The <code>CREATE TABLE</code> statement creates a<br />\ntable with a simple primary key that involves only one column, as shown<br />\nin the following screenshot:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_01.jpg\" alt=\"\" /></p>\n<p>The <code>symbol</code> field is assigned the<br />\nprimary key of the <code>dayquote01</code> table. This means that all the<br />\nrows of the same symbol are stored on the same node. Hence, this makes<br />\nthe retrieval of these rows very efficient.</p>\n<p>Alternatively, the primary key can be defined by an explicit<br />\n<code>PRIMARY KEY</code> clause, as shown in the following screenshot:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_02.jpg\" alt=\"\" /></p>\n<p>Unlike relational databases, Cassandra does not enforce a unique<br />\nconstraint on the primary key, as there is no <em>primary key<br />\nviolation</em> in Cassandra. An <code>INSERT</code> statement<br />\nusing an existing row key is allowed. Therefore, in CQL,<br />\n<code>INSERT</code> and <code>UPDATE</code> act in the same way, which is<br />\nknown as <strong>UPSERT</strong>. For example, we can<br />\ninsert two records into the table <code>dayquote01</code> with the same<br />\nsymbol and no primary key violation is alerted, as shown in the<br />\nfollowing screenshot:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_03.jpg\" alt=\"\" /></p>\n<p>The returned query result contains only one row,<br />\nnot two rows as expected. This is because the primary key is the symbol<br />\nand the row in the latter <code>INSERT</code> statement overrode the<br />\nrecord that was created by the former <code>INSERT</code> statement.<br />\nThere is no warning for a duplicate primary key. Cassandra simply and<br />\nquietly updated the row. This silent UPSERT behavior might sometimes<br />\ncause undesirable effects in the application logic.</p>\n<h3>Tip</h3>\n<p>Hence, it is very important for an application developer to handle<br />\nduplicate primary key situations in the application logic. Do not rely<br />\non Cassandra to check the uniqueness for you.</p>\n<p>In fact, the reason why Cassandra behaves like this becomes more clear<br />\nwhen we know how the internal storage engine stores the row, as shown by<br />\nCassandra CLI in the following screenshot:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_04.jpg\" alt=\"\" /></p>\n<p>The row key is <code>0001.HK</code>. It is used to<br />\nlocate which node is used to store the row. Whenever we insert or update<br />\nthe row of the same row key, Cassandra blindly locates the row and<br />\nmodifies the columns accordingly, even though an <code>INSERT</code><br />\nstatement has been used.</p>\n<p>Although a single column primary key is not uncommon, a primary key<br />\ncomposed of more than one column is much more practical.</p>\n<h2>Compound primary key and composite partition key</h2>\n<p>A compound primary key is composed of more than one<br />\ncolumn. The order of the columns is important. The<br />\nstructure of a compound primary key is depicted in the following figure:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_05.jpg\" alt=\"\" /></p>\n<p>Columns 1 to A are used as the partition key for Cassandra to determine<br />\nthe node location for the partition. The remaining columns, columns B to<br />\nN, are referred to as the clustering columns for the ordering of data.<br />\nThe clustering columns are used to locate a unique record in the data<br />\nnode. They are ordered, by default, and have the ability to use the<br />\n<code>ORDER BY [DESC]</code> clause in the <code>SELECT</code> statements.<br />\nMoreover, we can get the <code>MIN</code> or <code>MAX</code> values for<br />\nclustering keys with the <code>LIMIT 1</code> clause. We also need to use<br />\nthe clustering columns for the predicates in a<br />\n<code>WHERE</code> clause. We cannot leave out one<br />\nwhen trying to build a query.</p>\n<p>To define a compound primary key, an explicit <code>PRIMARY KEY</code><br />\nclause must be used in the <code>CREATE TABLE</code> or<br />\n<code>ALTER TABLE</code> statements. We can define a compound primary key<br />\nfor the table <code>dayquote03</code> , as shown in the following<br />\nscreenshot:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_06.jpg\" alt=\"\" /></p>\n<p>Because the first part of the primary key (that is <code>symbol</code>)<br />\nis the same as that of the simple primary key, the partition key is the<br />\nsame as that in <code>dayquote01</code>. Therefore, the node location is<br />\nthe same regardless of whether the primary key is compound or not, as in<br />\nthis case.</p>\n<p>So, what is difference between the simple primary key<br />\n(<code>symbol</code>) and this compound one<br />\n(<code>symbol, price_time</code>)? The additional field<br />\n<code>price_time</code> instructs Cassandra to guarantee the clustering<br />\nor ordering of the rows within the partition by the values of<br />\n<code>price_time</code>. Thus, the compound primary key sorts the rows of<br />\nthe same symbol by <code>price_time</code>. We insert two records into<br />\nthe <code>dayquote03</code> table and select all the records to see the<br />\neffect, as shown in the following screenshot:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_07.jpg\" alt=\"\" /></p>\n<p>Two records are returned as expected (compared to<br />\nonly one record in <code>dayquote01</code>).<br />\nMoreover, the ordering of the results is sorted by the values of<br />\n<code>price_time</code>. The following screenshot shows the internal view<br />\nof the rows in the <code>dayquote03</code> table:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_08.jpg\" alt=\"\" /></p>\n<p>The row key is still the partition key, that is,<br />\n<code>0001.HK</code>. However, Cassandra stores the two rows returned by<br />\nthe CQL <code>SELECT</code> statement, as one single<br />\ninternal row in its storage. The values of the clustering columns are<br />\nused as a prefix to the columns that are not specified in the<br />\n<code>PRIMARY KEY</code> clause. As Cassandra stores the internal columns<br />\nin the sorting order of the column name, the rows returned by the CQL<br />\n<code>SELECT</code> statement are sorted inherently. In a nutshell, on a<br />\nphysical node, when the rows for a partition key are stored in the order<br />\nthat is based on the clustering columns, the retrieval of rows is very<br />\nefficient.</p>\n<p>Now you know that the first part of a compound primary key is the<br />\npartition key. If we need to keep on storing 3,000 daily quotes (around<br />\n10 years) for <code>0001.HK</code> , although the CQL <code>SELECT</code><br />\nstatement returns 3,000 virtual rows, Cassandra requires to store these<br />\n3,000 virtual rows as one entire row on a node by the partition key. The<br />\nsize of the entire row gets bigger and bigger on a node as a result of<br />\nstoring more and more daily quotes. The row will quickly become gigantic<br />\nover a period of time and will then pose a serious performance problem,<br />\nas a result of an unbalanced cluster. The solution is a feature offered<br />\nby Cassandra called composite partition key.</p>\n<p>The composite partition key spreads the data over<br />\nmultiple nodes. It is defined by an extra set of<br />\nparentheses in the <code>PRIMARY KEY</code> clause. Let us create another<br />\ntable <code>dayquote04</code> with a composite partition key in order to<br />\nillustrate the effect. The columns <code>exchange</code> and<br />\n<code>symbol</code> are now members of a composite partition key, whereas<br />\nthe column <code>price_time</code> is a clustering column. We insert the<br />\nsame two records of different symbols into <code>dayquote04</code> , as<br />\nshown in the following screenshot:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_09.jpg\" alt=\"\" /></p>\n<p>With reference to the following screenshot, two internal rows are<br />\nreturned with their row keys as <code>SEHK:0001.HK</code> and<br />\n<code>SEHK:0002.HK</code> , respectively. Internally, Cassandra<br />\nconcatenates the columns in the composite partition key together as an<br />\ninternal row key. In short, the original row without a composite<br />\npartition key is now split into two rows. As the row keys are now<br />\ndifferent from each other, the corresponding rows can be stored on<br />\ndifferent nodes. The value of the clustering column<br />\n<code>price_time</code> is still used as a prefix in the internal column<br />\nname to preserve the ordering of data:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_10.jpg\" alt=\"\" /></p>\n<h3>Time-series data</h3>\n<p>Cassandra is  very suitable for handling<br />\ntime-series type of data, such as web server<br />\nlogfiles, usage data, sensor data, SIP packets, and so on. The tables<br />\n<code>dayquote01</code> to <code>dayquote04</code> in the previous<br />\nsections are used to store the daily stock quotes is an example of the<br />\ntime-series data.</p>\n<p>We have just seen in the last section that a composite partition key is<br />\na better way of not overwhelming the row. It limits the size of the rows<br />\non the basis of a symbol. However, this does partially solve the<br />\nproblem. The size of the row of a symbol still grows over a period of<br />\ntime. Do you have any other suggestion? We can define an artificial<br />\ncolumn, <code>quote_date</code> , in the table and set the composite<br />\npartition key to <code>exchange</code> and <code>quote_date</code><br />\ninstead, as shown in the following screenshot:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_11.jpg\" alt=\"\" /></p>\n<p>Now the composite partition key limits the size<br />\nof the rows on a daily basis, and makes the rows<br />\nmore manageable. This way of doing is analogous to inserting the data<br />\ninto different buckets labeled by a particular<br />\ndate. Hence, it is given a name called the <strong>date bucket<br />\npattern</strong>. Partitioning by the date also makes table<br />\nmaintenance easier by allowing you to drop the partition of<br />\n<code>quote_date</code>. One drawback of the date bucket pattern is that<br />\nyou always need to know the partition key in order to get the rows. So,<br />\nin <code>dayquote05</code> , you cannot get the latest<br />\n<code>quote_date</code> value using the <code>ORDER BY DESC</code> and<br />\n<code>LIMIT 1</code> clauses.</p>\n<p>The date bucket pattern gives an application developer a design option<br />\nto attain a more balanced cluster, but how balanced a cluster is depends<br />\non a number of factors in which the most important one is the selection<br />\nof the partitioner.</p>\n<h2>Partitioner</h2>\n<p>A partitioner is basically a hash function used to<br />\ncalculate the <code>TOKEN()</code> (the hash value) of a row key and so,<br />\nit determines how data is distributed across the nodes in a cluster.<br />\nChoosing a partitioner determines which node is used to place the first<br />\ncopy of data. Each row of data is uniquely identified by a partition key<br />\nand is distributed across the cluster by the value of the<br />\n<code>TOKEN()</code>. Cassandra provides the following three<br />\npartitioners:</p>\n<ul>\n<li>\n<p><code>Murmur3Partitioner</code> (default since version 1.2)</p>\n</li>\n<li>\n<p><code>RandomPartitioner</code> (default before version 1.2)</p>\n</li>\n<li>\n<p><code>ByteOrderedPartitioner</code></p>\n</li>\n</ul>\n<h3>Murmur3Partitioner</h3>\n<p><code>Murmur3Partitioner</code> provides faster<br />\nhashing and improved performance than the<br />\npartitioner <code>RandomPartitioner</code>. It is the default<br />\npartitioning strategy and the right choice for new clusters in almost<br />\nall cases. It uses the <em>MurmurHash</em> function that creates a<br />\n64-bit hash value of the partition key. The possible range of hash<br />\nvalues is from -2^63^ to +2^63^ -1. When using<br />\n<code>Murmur3Partitioner</code> , you can page through all the rows using<br />\nthe <code>TOKEN()</code> function in a CQL <code>SELECT</code> statement.</p>\n<h3>RandomPartitioner</h3>\n<p><code>RandomPartitioner</code> was the default<br />\npartitioner prior to Cassandra Version 1.2. It<br />\ndistributes data evenly across the nodes using an <em>MD5</em><br />\nhash value of the row key. The possible range of hash values is from 0<br />\nto 2^127^ -1. The MD5 hash function is slow in performance, that is why<br />\nCassandra has moved to Murmur3 hashes. When using<br />\n<code>RandomPartitioner</code> , you can page through all rows using the<br />\n<code>TOKEN()</code> function in a CQL <code>SELECT</code> statement.</p>\n<h3>ByteOrderedPartitioner</h3>\n<p><code>ByteOrderedPartitioner</code> , as its name suggests, is used for<br />\nordered partitioning. This partitioner orders rows<br />\nlexically by key bytes. Tokens are calculated by<br />\nlooking at the actual values of the partition key data and using a<br />\nhexadecimal representation of the leading character(s) in a key. For<br />\nexample, if you wanted to partition rows alphabetically, you can assign<br />\na B <code>TOKEN()</code> using its hexadecimal representation of<br />\n<code>0x42</code>.</p>\n<p>Using <code>ByteOrderedPartitioner</code> allows ordered scans by a<br />\nprimary key as though you were moving a cursor through a traditional<br />\nindex in a relational table. This type of range scan query is not<br />\npossible using <code>RandomPartitioner</code> because the keys are stored<br />\nin the order of their MD5 hash, and not in the sequential order of the<br />\nkeys.</p>\n<p>Apparently, performing range-scan on rows sounds like a desirable<br />\nfeature of <code>ByteOrderedPartitioner</code>. There are ways to achieve<br />\nthe same functionality using secondary indexes.<br />\nConversely, using <code>ByteOrderedPartitioner</code> is not recommended<br />\nfor the following reasons:</p>\n<ul>\n<li>\n<p><strong>Difficult load balancing</strong>: More administrative<br />\noverhead is required to load balance the cluster.<br />\n<code>ByteOrderedPartitioner</code> requires administrators to<br />\nmanually calculate partition ranges based on their estimates of the<br />\npartition key distribution.</p>\n</li>\n<li>\n<p><strong>Sequential writes can cause hot spots</strong>: If the<br />\napplication tends to write or update a sequential block of rows at a<br />\ntime, the writes will not be distributed across<br />\nthe cluster. They all go to one node. This is<br />\nfrequently a problem for applications dealing with timestamped data.</p>\n</li>\n<li>\n<p><strong>Uneven load balancing for multiple tables</strong>: If the<br />\napplication has multiple tables, chances are that these tables have<br />\ndifferent row keys and different distributions<br />\nof data. An ordered partitioner that is balanced for one table can<br />\ncause hot spots and uneven distribution for another table in the<br />\nsame cluster.</p>\n</li>\n</ul>\n<h3>Paging and token function</h3>\n<p>When using the <code>RandomPartitioner</code> or<br />\n<code>Murmur3Partitioner</code> , the rows are ordered by the hash of<br />\ntheir value. Hence, the order of the rows is  not<br />\nmeaningful. Using CQL, the rows can still be paged through<br />\neven when using <code>RandomPartitioner</code> or<br />\n<code>Murmur3Partitioner</code> using the <code>TOKEN()</code> function,<br />\nas shown in the following screenshot:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_12.jpg\" alt=\"\" /></p>\n<p><code>ByteOrderedPartitioner</code> arranges tokens in the same way as<br />\nkey values, while <code>RandomPartitioner</code> and<br />\n<code>Murmur3Partitioner</code> distribute tokens in a completely<br />\nunordered manner. The <code>TOKEN()</code> function makes it possible to<br />\npage through the unordered partitioner results. It actually queries<br />\nresults directly using tokens.</p>\n<h2>Secondary indexes</h2>\n<p>As Cassandra only allows each table to have one<br />\nprimary key, it supports secondary index on columns other than those in<br />\nthe primary key. The benefit is a fast, efficient lookup of data<br />\nmatching the indexed columns in the <code>WHERE</code> clause. Each table<br />\ncan have more than one secondary index. Cassandra uses secondary indexes<br />\nto find the rows that are not using the row key. Behind the scenes, the<br />\nsecondary index is implemented as a separate, hidden table that is<br />\nmaintained automatically by the internal process of Cassandra. As with<br />\nrelational databases, keeping secondary indexes up to date is not free,<br />\nso unnecessary indexes should be avoided.</p>\n<h3>Note</h3>\n<p>the between a<br />\nprimary index and a secondary index is that the primary index is a<br />\ndistributed index used to locate the node that stores the row key,<br />\nwhereas the secondary index is a local index just to index the data on<br />\nthe local node.</p>\n<p>Therefore, the secondary index will not be able to know immediately the<br />\nlocations of all matched rows without having examined all the nodes in<br />\nthe cluster. This makes the performance of the secondary index<br />\nunpredictable.</p>\n<h3>Note</h3>\n<p>The secondary index is the most efficient when using equality<br />\npredicates. This is indeed a limitation that must have at least one<br />\nequality predicate clause to hopefully limit the set of rows that need<br />\nto be read into memory.</p>\n<p>In addition, the secondary index cannot be created on the primary key<br />\nitself.</p>\n<h3>Note</h3>\n<p><strong>Caveat!</strong></p>\n<p>Secondary indexes in Cassandra are<br />\n<em>NOT</em> equivalent to those in the traditional RDBMS. They<br />\nare not akin to a B-tree index in RDBMS. They are mostly like a hash.<br />\nSo, the range queries do not work on secondary indexes in Cassandra,<br />\nonly equality queries work on secondary indexes.</p>\n<p>We can use the CQL <code>CREATE INDEX</code> statement to create an index<br />\non a column after we define a table. For example, we might want to add a<br />\ncolumn <code>sector</code> to indicate the sector that the stock belongs<br />\nto, as shown in the following screenshot:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_13.jpg\" alt=\"\" /></p>\n<p>If we want to search <code>dayquote06</code> for<br />\nsymbols that belong to <code>Properties</code> , we might run the command,<br />\nas shown in the following screenshot:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_14.jpg\" alt=\"\" /></p>\n<p>As <code>sector</code> is not in the primary key, we cannot query<br />\nCassandra directly by <code>sector</code>. Instead, we can create a<br />\nsecondary index on the column <code>sector</code> to make this possible,<br />\nas shown in the following screenshot:</p>\n<p><img src=\"https://raw.githubusercontent.com/fenago/apache-cassandra/master/images/8884OS_04_15.jpg\" alt=\"\" /></p>\n<p>The index name <code>dayquote06_sector_idx</code> is<br />\noptional, but must be unique within the keyspace. Cassandra assigns a<br />\nname such as <code>dayquote06_idx</code> if you do not provide a name. We<br />\ncan now query Cassandra for daily stock quotes by <code>sector</code>.</p>\n<p>You can see that the columns in the primary key are not present in the<br />\n<code>WHERE</code> predicate clause in the previous screenshot and<br />\nCassandra uses the secondary index to look for the rows matching the<br />\nselection condition.</p>\n<h3>Multiple secondary indexes</h3>\n<p>Cassandra supports multiple secondary indexes on a table. The<br />\n<code>WHERE</code> clause is executed if at least<br />\none column is involved in a secondary index. Thus,<br />\nwe can use multiple conditions in the<br />\n<code>WHERE</code> clause to filter the results. When multiple<br />\noccurrences of data match a condition in the <code>WHERE</code> predicate<br />\nclause, Cassandra selects the least frequent occurrence of a condition<br />\nto process first so as to have a better query efficiency.</p>\n<p>When a potentially expensive query is attempted, such as a range query,<br />\nCassandra requires the <code>ALLOW FILTERING</code><br />\nclause, which can apply additional filters to the result set for values<br />\nof other non-indexed columns. It works very slowly because it scans all<br />\nrows in all nodes. The <code>ALLOW FILTERING</code> clause is used to<br />\nexplicitly direct Cassandra to execute that potentially expensive query<br />\non any <code>WHERE</code> clause without creating secondary indexes,<br />\ndespite unpredictability of the performance.</p>\n<h3>Secondary index do&rsquo;s and don&rsquo;ts</h3>\n<p>The secondary index is best on a table that has<br />\nmany rows that contain fewer unique values, that is<br />\nlow cardinality in the relational database terminologies, which is<br />\ncounterintuitive to the relational people. The more unique values that<br />\nexist in a particular column, the more overhead you will have to query<br />\nand maintain the index. Hence, it is not suitable for querying a huge<br />\nvolume of records for a small number of results.</p>\n<h3>Tip</h3>\n<p>Do index the columns with values that have low cardinality. Cassandra<br />\nstores secondary indexes only for local rows in the<br />\ndata node as a hash-multimap or as bitmap indexes, you can refer to it<br />\nat <a href=\"https://issues.apache.org/jira/browse/CASSANDRA-1472\">https://issues.apache.org/jira/browse/CASSANDRA-1472</a>.</p>\n<p>Secondary indexes should be avoided in the following situations:</p>\n<ul>\n<li>\n<p>On high-cardinality columns for a small number of results out of a<br />\nhuge volume of rows</p>\n<p>An index on a high-cardinality column will incur many seeks for very<br />\nfew results. For columns containing unique values, using an index<br />\nfor convenience is fine from a performance perspective, as long as<br />\nthe query volume to the indexed column family is moderate and not<br />\nunder constant load.</p>\n</li>\n<li>\n<p>In tables that use a counter column</p>\n</li>\n<li>\n<p>On a frequently updated or deleted column</p>\n<p>Cassandra stores tombstones (a marker in a row that indicates that a<br />\ncolumn was deleted. During compaction, marked columns are deleted in<br />\nthe index (a hidden table) until the tombstone limit reaches 100 K<br />\ncells. After exceeding this limit, the query that uses the indexed<br />\nvalue will fail.</p>\n</li>\n<li>\n<p>To look for a row in a large partition</p>\n<p>A query on an indexed column in a large cluster typically requires<br />\ncollating responses from multiple data partitions. The query<br />\nresponse slows down as more machines get added to the cluster.</p>\n</li>\n</ul>\n<h3>Tip</h3>\n<p><strong>Important points to take note of</strong></p>\n<ul>\n<li>Don&rsquo;t index on high-cardinality columns</li>\n<li>Don&rsquo;t use index in tables having a counter<br />\ncolumn</li>\n<li>Don&rsquo;t index on a frequently updated or deleted column</li>\n<li>Don&rsquo;t abuse the index to look for a row in a large partition</li>\n</ul>\n<h2>Summary</h2>\n<p>We have learned about the primary and secondary indexes in this lab.<br />\nRelated topics such as compound primary key, composite partition key,<br />\nand partitioner are also introduced. With the help of the explanation of<br />\nthe internal storage and inner working mechanisms of Cassandra, you<br />\nshould now be able to state the difference between the primary index and<br />\nthe secondary index, as well as use them properly in your data model.</p>\n<p>In the next lab, we will start building the first version of the<br />\ntechnical analysis application using Cassandra and Python. A quick<br />\ninstallation and setup guide on how to connect Python to Cassandra and<br />\ncollect market data will also be provided.</p>\n\n</div>"
          }
        ]
      }
    },
    {
      "text": "USE fenago;\r\n\r\nCREATE TABLE dayquote01 (\r\n  symbol varchar PRIMARY KEY,\r\n  exchange varchar,\r\n  price_time timestamp,\r\n  open_price float,\r\n  high_price float,\r\n  low_price float,\r\n  close_price float,\r\n  volume double\r\n);\r\n",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T11:35:24+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false
        },
        "editorMode": "ace/mode/text"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591529545096_233056869",
      "id": "paragraph_1591529545096_233056869",
      "dateCreated": "2020-06-07T11:32:25+0000",
      "dateStarted": "2020-06-07T11:35:24+0000",
      "dateFinished": "2020-06-07T11:35:26+0000",
      "status": "FINISHED",
      "$$hashKey": "object:16714"
    },
    {
      "text": "USE fenago;\r\n\r\nCREATE TABLE dayquote02 (\r\n  symbol varchar,\r\n  exchange varchar,\r\n  price_time timestamp,\r\n  open_price float,\r\n  high_price float,\r\n  low_price float,\r\n  close_price float,\r\n  volume double,\r\n  PRIMARY KEY (symbol)\r\n);",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T11:35:29+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false
        },
        "editorMode": "ace/mode/text"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591529544927_-1869156518",
      "id": "paragraph_1591529544927_-1869156518",
      "dateCreated": "2020-06-07T11:32:24+0000",
      "dateStarted": "2020-06-07T11:35:29+0000",
      "dateFinished": "2020-06-07T11:35:30+0000",
      "status": "FINISHED",
      "$$hashKey": "object:16715"
    },
    {
      "text": "USE fenago;\r\n\r\nINSERT INTO dayquote01\r\n  (exchange, symbol, price_time, open_price,\r\n   high_price, low_price, close_price, volume)\r\n  values\r\n  ('SEHK', '0001.HK', '2014-06-01 10:00:00', 11.1,\r\n   12.2, 10.0, 10.9, 1000000.0);\r\n \r\nINSERT INTO dayquote01\r\n  (exchange, symbol, price_time, open_price,\r\n   high_price, low_price, close_price, volume)\r\n  values\r\n  ('SEHK', '0001.HK', '2014-05-31 10:00:00', 11.0,\r\n   12.0, 10.0, 11, 500000.0);\r\n\r\nSELECT * FROM dayquote01;",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T11:35:35+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "mode": "table",
              "height": 300,
              "optionOpen": false,
              "setting": {
                "table": {
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "names": {
                      "symbol": "string",
                      "close_price": "string",
                      "exchange": "string",
                      "high_price": "string",
                      "low_price": "string",
                      "open_price": "string",
                      "price_time": "string",
                      "volume": "string"
                    },
                    "updated": false
                  },
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]",
                  "tableOptionValue": {
                    "useFilter": false,
                    "showPagination": false,
                    "showAggregationFooter": false
                  },
                  "updated": false,
                  "initialized": false
                }
              },
              "commonSetting": {}
            }
          }
        },
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false
        },
        "editorMode": "ace/mode/text"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591529544856_1368515978",
      "id": "paragraph_1591529544856_1368515978",
      "dateCreated": "2020-06-07T11:32:24+0000",
      "dateStarted": "2020-06-07T11:35:33+0000",
      "dateFinished": "2020-06-07T11:35:33+0000",
      "status": "FINISHED",
      "$$hashKey": "object:16716"
    },
    {
      "text": "%sh\r\ncat > script.cli <<EOL\r\ndescribe dayquote01;\r\nEOL\r\ncqlsh -f  script.cli --keyspace=fenago",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T11:35:36+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "sh",
          "editOnDblClick": false,
          "completionSupport": false
        },
        "editorMode": "ace/mode/sh"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591529544369_-1593018447",
      "id": "paragraph_1591529544369_-1593018447",
      "dateCreated": "2020-06-07T11:32:24+0000",
      "dateStarted": "2020-06-07T11:35:36+0000",
      "dateFinished": "2020-06-07T11:35:37+0000",
      "status": "FINISHED",
      "$$hashKey": "object:16717"
    },
    {
      "text": "USE fenago;\r\n\r\nCREATE TABLE dayquote03 (\r\n  symbol varchar,\r\n  exchange varchar,\r\n  price_time timestamp,\r\n  open_price float,\r\n  high_price float,\r\n  low_price float,\r\n  close_price float,\r\n  volume double,\r\n  PRIMARY KEY (symbol, price_time)\r\n);",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T11:35:41+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false
        },
        "editorMode": "ace/mode/text"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591529558668_-1132278329",
      "id": "paragraph_1591529558668_-1132278329",
      "dateCreated": "2020-06-07T11:32:38+0000",
      "dateStarted": "2020-06-07T11:35:41+0000",
      "dateFinished": "2020-06-07T11:35:42+0000",
      "status": "FINISHED",
      "$$hashKey": "object:16718"
    },
    {
      "text": "USE fenago;\r\n\r\nINSERT INTO dayquote03\r\n  (exchange, symbol, price_time, open_price,\r\n   high_price, low_price, close_price, volume)\r\n  values\r\n  ('SEHK', '0001.HK', '2014-06-01 10:00:00', 11.1,\r\n   12.2, 10.0, 10.9, 1000000.0);\r\n \r\nINSERT INTO dayquote03\r\n  (exchange, symbol, price_time, open_price,\r\n   high_price, low_price, close_price, volume)\r\n  values\r\n  ('SEHK', '0001.HK', '2014-05-31 10:00:00', 11.0,\r\n   12.0, 10.0, 11, 500000.0);\r\n\r\nSELECT * FROM dayquote03;\r\n",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T11:36:49+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "mode": "table",
              "height": 300,
              "optionOpen": false,
              "setting": {
                "table": {
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "names": {
                      "symbol": "string",
                      "price_time": "string",
                      "close_price": "string",
                      "exchange": "string",
                      "high_price": "string",
                      "low_price": "string",
                      "open_price": "string",
                      "volume": "string"
                    },
                    "updated": false
                  },
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]",
                  "tableOptionValue": {
                    "useFilter": false,
                    "showPagination": false,
                    "showAggregationFooter": false
                  },
                  "updated": false,
                  "initialized": false
                }
              },
              "commonSetting": {}
            }
          }
        },
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false
        },
        "editorMode": "ace/mode/text"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591529558947_-1844559898",
      "id": "paragraph_1591529558947_-1844559898",
      "dateCreated": "2020-06-07T11:32:38+0000",
      "dateStarted": "2020-06-07T11:36:48+0000",
      "dateFinished": "2020-06-07T11:36:48+0000",
      "status": "FINISHED",
      "$$hashKey": "object:16719"
    },
    {
      "text": "%sh\r\ncat > script.cli <<EOL\r\ndescribe dayquote03;\r\nEOL\r\ncqlsh -f  script.cli --keyspace=fenago",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T11:36:51+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "sh",
          "editOnDblClick": false,
          "completionSupport": false
        },
        "editorMode": "ace/mode/sh"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591529558809_-440911681",
      "id": "paragraph_1591529558809_-440911681",
      "dateCreated": "2020-06-07T11:32:38+0000",
      "dateStarted": "2020-06-07T11:36:51+0000",
      "dateFinished": "2020-06-07T11:36:51+0000",
      "status": "FINISHED",
      "$$hashKey": "object:16720"
    },
    {
      "text": "USE fenago;\r\n\r\nCREATE TABLE dayquote04 (\r\n  symbol varchar,\r\n  exchange varchar,\r\n  price_time timestamp,\r\n  open_price float,\r\n  high_price float,\r\n  low_price float,\r\n  close_price float,\r\n  volume double,\r\n  PRIMARY KEY ((exchange, symbol), price_time)\r\n);\r\n\r\nINSERT INTO dayquote04\r\n  (exchange, symbol, price_time, open_price,\r\n   high_price, low_price, close_price, volume)\r\n  values\r\n  ('SEHK', '0001.HK', '2014-06-01 10:00:00', 11.1,\r\n   12.2, 10.0, 10.9, 1000000.0);\r\n \r\nINSERT INTO dayquote04\r\n  (exchange, symbol, price_time, open_price,\r\n   high_price, low_price, close_price, volume)\r\n  values\r\n  ('SEHK', '0002.HK', '2014-06-01 10:05:00', 11.0,\r\n   12.0, 10.0, 11, 500000.0);\r\n",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T11:36:56+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false
        },
        "editorMode": "ace/mode/text"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591529558287_-656035239",
      "id": "paragraph_1591529558287_-656035239",
      "dateCreated": "2020-06-07T11:32:38+0000",
      "dateStarted": "2020-06-07T11:36:56+0000",
      "dateFinished": "2020-06-07T11:36:57+0000",
      "status": "FINISHED",
      "$$hashKey": "object:16721"
    },
    {
      "text": "%sh\r\ncat > script.cli <<EOL\r\ndescribe dayquote04;\r\nEOL\r\ncqlsh -f  script.cli --keyspace=fenago",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T11:36:59+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "sh",
          "editOnDblClick": false,
          "completionSupport": false
        },
        "editorMode": "ace/mode/sh"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591529544107_-846714696",
      "id": "paragraph_1591529544107_-846714696",
      "dateCreated": "2020-06-07T11:32:24+0000",
      "dateStarted": "2020-06-07T11:36:59+0000",
      "dateFinished": "2020-06-07T11:37:00+0000",
      "status": "FINISHED",
      "$$hashKey": "object:16722"
    },
    {
      "text": "USE fenago;\r\n\r\nCREATE TABLE dayquote05 (\r\n  symbol varchar,\r\n  exchange varchar,\r\n  price_time timestamp,\r\n  quote_date varchar,\r\n  open_price float,\r\n  high_price float,\r\n  low_price float,\r\n  close_price float,\r\n  volume double,\r\n  PRIMARY KEY ((exchange, quote_date), symbol, price_time)\r\n);",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T11:37:02+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false
        },
        "editorMode": "ace/mode/text"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591529543167_-1899870756",
      "id": "paragraph_1591529543167_-1899870756",
      "dateCreated": "2020-06-07T11:32:23+0000",
      "dateStarted": "2020-06-07T11:37:02+0000",
      "dateFinished": "2020-06-07T11:37:04+0000",
      "status": "FINISHED",
      "$$hashKey": "object:16723"
    },
    {
      "text": "USE fenago;\r\n\r\nSELECT symbol FROM dayquote04\r\n WHERE TOKEN(exchange,symbol) < TOKEN('SEHK','0002.HK');\r\n",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T11:37:08+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "mode": "table",
              "height": 300,
              "optionOpen": false,
              "setting": {
                "table": {
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "names": {
                      "symbol": "string"
                    },
                    "updated": false
                  },
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]",
                  "tableOptionValue": {
                    "useFilter": false,
                    "showPagination": false,
                    "showAggregationFooter": false
                  },
                  "updated": false,
                  "initialized": false
                }
              },
              "commonSetting": {}
            }
          }
        },
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false
        },
        "editorMode": "ace/mode/text"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591529681427_-859139409",
      "id": "paragraph_1591529681427_-859139409",
      "dateCreated": "2020-06-07T11:34:41+0000",
      "dateStarted": "2020-06-07T11:37:07+0000",
      "dateFinished": "2020-06-07T11:37:07+0000",
      "status": "FINISHED",
      "$$hashKey": "object:16724"
    },
    {
      "text": "USE fenago;\r\n\r\nCREATE TABLE dayquote06 (\r\n  symbol varchar,\r\n  exchange varchar,\r\n  sector varchar,\r\n  price_time timestamp,\r\n  quote_date varchar,\r\n  open_price float,\r\n  high_price float,\r\n  low_price float,\r\n  close_price float,\r\n  volume double,\r\n  PRIMARY KEY ((exchange, quote_date), symbol, price_time)\r\n);\r\n\r\nINSERT INTO dayquote06\r\n  (exchange, symbol, sector, price_time, open_price,\r\n   high_price, low_price, close_price, volume, quote_date)\r\n  values\r\n  ('SEHK', '0001.HK', 'Properties', '2014-06-01 10:00:00', 11.1,\r\n   12.2, 10.0, 10.9, 1000000.0, '20140601');\r\n \r\nINSERT INTO dayquote06\r\n  (exchange, symbol, sector, price_time, open_price,\r\n   high_price, low_price, close_price, volume, quote_date)\r\n  values\r\n  ('SEHK', '0002.HK', 'Utilities', '2014-06-01 10:05:00', 11.0,\r\n   12.0, 10.0, 11, 500000.0, '20140601');\r\n",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T11:37:11+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false
        },
        "editorMode": "ace/mode/text"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591529680008_-1822196484",
      "id": "paragraph_1591529680008_-1822196484",
      "dateCreated": "2020-06-07T11:34:40+0000",
      "dateStarted": "2020-06-07T11:37:11+0000",
      "dateFinished": "2020-06-07T11:37:12+0000",
      "status": "FINISHED",
      "$$hashKey": "object:16725"
    },
    {
      "text": "USE fenago;\r\n\r\nSELECT symbol FROM dayquote06 WHERE sector = 'Properties';\r\n",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T11:39:02+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "mode": "table",
              "height": 300,
              "optionOpen": false,
              "setting": {
                "table": {
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "names": {
                      "symbol": "string"
                    },
                    "updated": false
                  },
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]",
                  "tableOptionValue": {
                    "useFilter": false,
                    "showPagination": false,
                    "showAggregationFooter": false
                  },
                  "updated": false,
                  "initialized": false
                }
              },
              "commonSetting": {}
            }
          }
        },
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false
        },
        "editorMode": "ace/mode/text"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591529678868_-1713312227",
      "id": "paragraph_1591529678868_-1713312227",
      "dateCreated": "2020-06-07T11:34:38+0000",
      "dateStarted": "2020-06-07T11:39:02+0000",
      "dateFinished": "2020-06-07T11:39:02+0000",
      "status": "FINISHED",
      "$$hashKey": "object:16726"
    },
    {
      "text": "USE fenago;\r\n\r\nCREATE INDEX dayquote06_sector_idx ON dayquote06 (sector);\r\n\r\n",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T11:39:40+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false
        },
        "editorMode": "ace/mode/text"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591529676746_124982321",
      "id": "paragraph_1591529676746_124982321",
      "dateCreated": "2020-06-07T11:34:36+0000",
      "dateStarted": "2020-06-07T11:39:40+0000",
      "dateFinished": "2020-06-07T11:39:40+0000",
      "status": "ERROR",
      "$$hashKey": "object:16727"
    },
    {
      "text": "USE fenago;\r\n\r\nSELECT symbol FROM dayquote06 WHERE sector = 'Properties';\r\n",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T11:39:44+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "mode": "table",
              "height": 300,
              "optionOpen": false,
              "setting": {
                "table": {
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "names": {
                      "symbol": "string"
                    },
                    "updated": false
                  },
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]",
                  "tableOptionValue": {
                    "useFilter": false,
                    "showPagination": false,
                    "showAggregationFooter": false
                  },
                  "updated": false,
                  "initialized": false
                }
              },
              "commonSetting": {}
            }
          }
        },
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false
        },
        "editorMode": "ace/mode/text"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591529513849_1824944463",
      "id": "paragraph_1591529513849_1824944463",
      "dateCreated": "2020-06-07T11:31:53+0000",
      "dateStarted": "2020-06-07T11:39:42+0000",
      "dateFinished": "2020-06-07T11:39:42+0000",
      "status": "FINISHED",
      "$$hashKey": "object:16728"
    },
    {
      "user": "anonymous",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false
        },
        "editorMode": "ace/mode/text"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591529982890_-548303557",
      "id": "paragraph_1591529982890_-548303557",
      "dateCreated": "2020-06-07T11:39:42+0000",
      "status": "READY",
      "$$hashKey": "object:16729"
    }
  ],
  "name": "lab_4",
  "id": "2FCDBRD2F",
  "defaultInterpreterGroup": "cassandra",
  "version": "0.9.0-preview1",
  "noteParams": {},
  "noteForms": {},
  "angularObjects": {},
  "config": {
    "isZeppelinNotebookCronEnable": false,
    "looknfeel": "default",
    "personalizedMode": "false"
  },
  "info": {},
  "path": "/lab_4"
}